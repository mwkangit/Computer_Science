# Database



## 설계



### 개념적 설계

- 현실 세계에 대한 인식을 추상적 개념으로 표현한 것이다.
- 스키마 모델링과 트랜잭션 모델링을 병행한다.
- 요구 분석 단계에서 나온 결과를 DBMS에 독립적 ERD로 작성한다.



### 논리적 설계

- 현실 세계 자료를 컴퓨터 처리할 수 있는 물리적 저장 장치에 저장할 수 있도록 변환하기 위해 특정 DBMS가 지원하는 논리적 자료 구조로 변환한다.
- 개념적 설계는 개념 스키마를 설계하는 것이지만 논리적 설계는 개념 스키마 평가, 정제 그리고 특정 DBMS에 종속적인 논리적 스키마를 설계하는 것이다.
- 트랜잭션의 인터페이스를 설계한다.
- 즉, DBMS의 관점에서 개념적 스키마를 변환하는 것이다.
- RDB라면 테이블을 설계하고 정규화 과정을 하는 단계이다.



### 물리적 설계

- 논리적으로 설계된 스키마를 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터베이스로 변환하는 것이다.
- 파일의 저장 구조 및 엑세스 경로, 인덱스의 구조와 저장 레코드의 크기, 순서, 접근 경로를 결정하며 반응시간, 공간활용도, 트랜잭션 처리량을 고려하여 설계를 해야 한다.



## 키

데이터베이스에서 조건을 만족하는 튜플을 찾을 때 다른 튜플들과 구별할 수 있는 유일한 기준이 되는 애트리뷰트이다.



### 후보키

- 릴레이션을 구성하는 속성들 중에서 튤플을 유일하게 식별하기 위해 사용하는 속성들의 부분집합이다.
- 유일성과 최소성을 만족해야한다.
- 모든 릴레이션은 반드시 하나 이상의 후보키를 가져야한다.



### 기본키

- 후보키 중에서 선택한 주키이다.
- 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성이다.
- NULL 값을 가질 수 없다. (개체 무결성)
- 동일한 값이 중복되어 저장될수 없다. (개체 무결성)



### 대체키

- 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키이다.
- 보조키라고도 불린다.



### 슈퍼키

- 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키이다.
- 유일성의 특성을 만족하는 속성 또는 속성들의 집합이다.
- 릴레이션을 구성하는 모든 튜플 중 슈퍼키로 구성된 속성의 집합과 동일한 값은 나타내지 않는다.
- 릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족하지만 최소성을 만족하지 않는다.



### 외래키

- 관계를 맺고 있는 릴레이션들이 서로의 값을 참조하기 위해 상대 테이블의 기본키를 자신의 속성으로 갖는 것이다.
- 참조되는 릴레이션의 기본키와 대응되어 릴레이션 간에 참조 관계를 표현하는데 중요한 도구가 된다.
- 외래키로 지정되면 참조 테이블의 기본키에 없는 값은 입력할 수 없다. (참조 무결성)



### 복합키

- 기본키가 2개 이상으로 구성된 것이다.

[설계 & 키](https://velog.io/@inyong_pang/Database-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%84%A4%EA%B3%84-%EB%B0%8F-%EA%B5%AC%EC%A1%B0)

[키](https://limkydev.tistory.com/108)



## 데이터 무결성

데이터의 정확성, 일관성, 유효성이 유지되는 것을 말한다.

개참도널고키

- 정확성 : 중복이나 누락이 없는 상태를 뜻한다.
- 일관성 : 원인과 결과의 의미가 연속적으로 보장되어 변하지 않는 상태를 뜻한다.
- 무결성이 없다면 : 중복된 데이터 존재, 부모와 자식 데이터 간의 논리적 관계 깨짐, 잦은 에러와 재개발 비용 발생 문제가 발생한다.



### 개체 무결성

- 기본키 제약이며 테이블은 기본키를 지정하고 그에 따른 무결성 원칙을 지켜야하는 조건이다.
- 기본키에는 NULL이 들어갈 수 없다.
- 기본키는 테이블 내에 오직 하나의 값만 존재해야 한다. 즉, 유일성이 보장 되어야하며 중복을 허용하지 않는다.



### 참조 무결성

- 외래키 제약이며 테이블 간의 참조 관계를 선언하는 제약조건이다.
- 외래키의 값은 NULL이거나 참조 릴레이션의 기본키 값과 동일해야 한다.
- 외래키 속성은 참조할 수 없는 값을 지닐 수 없다. 즉, 외래키 속성 값이 상위 테이블의 인스턴스에 반드시 존재하거나 NULL이어야 한다.



### 도메인 무결성

- 테이블에 존재하는 필드의 무결성을 보장하기 위한 것으로 필드의 타입, NULL 값 허용 등에 대한 사항을 정의하고 올바른 데이터가 입력되었는지 확인하는 조건이다.
- 즉, 속성에 알맞은 값이 들어갔는지 확인하는 것이다.
- 예) `성별 : 남자 (O), 성별 : 강민우 (X)`



### NULL 무결성

- 테이블의 특정 속성 값이 NULL이 될수 없게 하는 조건이다.



### 고유 무결성

- 테이블의 특정 속성에 대해 각 레코드들이 갖는 값들이 서로 달라야하는 조건이다.



### 키 무결성

- 하나의 테이블에는 적어도 하나의 키가 존재해야 한다.



### 관계 무결성

- 테이블의 어느 한 레코드의 삽입 가능 여부 또는 한 테이블과 다른 테이블의 레코드들 사이의 관계에 대한 적절성 여부를 지정한 조건이다.

[데이터 무결성](https://cocoon1787.tistory.com/778)



## 트랜잭션

여러 개의 작업을 하나로 묶은 실행 유닛을 뜻한다.

데이터베이스의 상태를 변환시키는 기능을 수행하기 위한 하나 이상의 쿼리를 모아 놓은 하나의 작업 단위를 말한다.

- 모든 묶은 작업이 완료되어야 정상적으로 종료하며 하나라도 실패하면 모든 작업 실패로 판단한다.

ACID

- 데이터베이스 내에서 일어나는 하나의 트랜잭션의 안전성을 보장하기 위해 필요한 성질이다.



### Atomicity

- 트랜잭션이 안전성 보장을 위해 가져야 할 성질이다.

- 한 트랜잭션의 연산들이 모두 성공하거나 반대로 전부 실패하는 성질이다.
- 하나의 작업이라도 실패하면 실패이다.
- 원자성은 작업이 모두 반영되거나 모두 반영되지 않음으로서 결과를 예측할 수 있어야 한다.
- 예 ) A는 출금하여 B계좌에 입금할 때 B가 문제가 발생하면 문제 파악이 불가능해지며 A가 출금한 돈은 사라진 돈이 된다. 이때 원자성이 필요하다. 즉, 롤백해야 한다.



### Consistency

- 하나의 트랜잭션 이전과 이후, 데이터베이스의 상태는 이전과 같이 유효해야 한다.
- 트랜잭션이 일어난 이후의 데이터베이스는 데이터베이스의 제약이나 규칙을 만족해야 한다.
- 예 ) '모든 고객은 반드시 이름을 가지고 있어야 한다'는 제약이 있을 때 1. 이름이 없는 새로운 고객을 추가하는 쿼리 2. 기존 고객의 이름을 삭제하는 쿼리는 일관성을 위반한다.



### Isolation

- 모든 트랜잭션은 다른 트랜잭션으로부터 독립되어야 한다.
- 실제로 동시에 여러 개의 트랜잭션들이 수행될 때, 각 트랜젝션은 고립되어 있어 연속으로 실행된 것과 동일한 결과를 나타낸다.
- 트랜잭션이 동시에 실행될 때와 연속으로 실행될 때의 데이터베이스 상태가 동일해야 한다.
- 트랜잭션 실행 도중 다른 트랜잭션의 영향을 받아 잘못된 결과를 만들어서는 안된다.
- 예 ) 만원이 들어있는 계좌에서 동시에 B, C 계좌에 각각 6천원씩 보낼때 마이너스 통장이 발생하면 안되며 송금 작업을 연속으로 실행하는 것과 동시에 실행하는 결과는 동일한 결과가 나타나야 한다.



### Durability

- 하나의 트랜잭션이 성공적으로 수행되었다면 해당 트랜잭션에 대한 로그가 남아야하는 성질을 말한다.
- 만약 런타임 오류나 시스템 오류가 발생하더라도 해당 기록은 영구적이어야 한다.
- 트랜잭션이 성공하면 그 트랜잭션이 갱신한 데이터베이스 내용은 영구적으로 저장된다.
- 예 ) 은행 데이터베이스가 오류로 종료되어도 계좌이체 내역은 기록으로 남아 있어야 한다. 만약 계좌 이체를 로그로 기록하기 전에 오류로 데이터베이스가 종료되면 해당 이체 내역은 실패로 돌아가고 각 계좌들은 계좌 이체 이전 상태로 롤백된다.

[트랜잭션](https://hanamon.kr/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%98-acid-%EC%84%B1%EC%A7%88/)



## 데이터베이스 관계

3가지 유형



### 1:1

- 하나의 레코드가 다른 테이블의 레코드 한 개와 연결된 경우이다.
- 어느 엔티티 쪽에서 상대 엔티티와 반드시 단 하나의 관계를 가지는 것이다.



### 1:N

- 하나의 레코드가 서로 다른 여러 개의 레코드와 연결된 경우이다.
- 한 쪽 엔티티가 관계를 맺은 엔티티 쪽의 여러 객체를 가질 수 있는 것을 의미한다.



### N:M

- 여러 개의 레코드가 다른 테이블의 여러 개의 레코드와 관계가 있는 경우이다.
- 스키마를 디자인한다면 join 테이블을 만들어야 한다. 1:N N:1로 풀어서 릴레이션을 구성하는 것이 좋다.
- 양쪽 엔티티 모두에서 1:N 관계를 가지는 것으로 보면 되며 서로가 서로를 1:N 관계로 보는 것이다.

[데이터베이스 관계](https://hanamon.kr/%EA%B4%80%EA%B3%84%ED%98%95-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%84%A4%EA%B3%84-%EA%B4%80%EA%B3%84-%EC%A2%85%EB%A5%98/)



## DBMS SQL

데이터베이스에서 모든 작업은 SQL로 이루어지며 종류는 DDL, DML, DCL이 있다.

DDL : 데이터베이스와 테이블을 생성 및 변경, 제거 한다.

DML : 생성된 테이블 내에 있는 데이터들을 입력, 변경, 수정, 조회 한다.

DCL : 데이터베이스의 접속 권한 등을 수정한다.



### DDL

- 데이터 정의어 이다.

- 데이터베이스를 정의하는 언어를 말하며 데이터를 생성하거나 수정, 삭제 등 데이터의 전체 골격을 결정하는 역할을 하는 언어이다.
- 데이터 구조를 정의하는데 사용되는 언어이다.
- CREATE : 데이터베이스, 테이블 등을 생성하는 역할을 한다.
- ALTER : 테이블을 수정하는 역할을 한다.
- DROP : 데이터베이스, 테이블을 삭제하는 역할을 한다.
- TRUNCATE : 테이블을 초기화 시키는 역할을 한다.



### DML

- 데이터 조작어 이다.
- 정의된 데이터베이스에 입력된 레코드를 조회하거나 수정하거나 삭제하는 등의 역할을 하는 언어이다.
- 테이블에 있는 행과 열을 조작하는 언어이다.
- SELECT : 데이터를 조회하는 역할을 한다.
- INSERT : 데이터를 삽입하는 역할을 한다.
- UPDATE : 데이터를 수정하는 역할을 한다.
- DELETE : 데이터를 삭제하는 역할을 한다.



### DCL

- 데이터 제어어 이다.
- 데이터베이스에 접근하거나 객체에 권한을 주는 등 역할을 하는 언어이다.
- 데이터의 보안, 무결성, 회복 등을 정의하는데 사용한다.
- GRANT : 특정 데이터베이스 사용자에게 특정 작업에 대한 수행권한 부여를 한다.
- REVOKE : 특정 데이터베이스 사용자에게 특정 작업에 대한 권한을 박탈, 회수한다.
- COMMIT : 트랜잭션의 작업이 정상적으로 완료되었음을 관리자에게 알려준다.
- ROLLBACK : 트랜잭션의 작업이 비정상적으로 종료 되었을 때 원래의 상태로 복구한다.

[DBMS SQL](https://cbw1030.tistory.com/71)



## 이상

릴레이션에서 일부 속성들의 종속이나 데이터의 중복으로 인해 데이터 조작시 불일치가 발생하는 것이다.



### 삽입 이상

- 자료를 삽입할 때 의도하지 않은 자료까지 삽입해야만 자료를 테이블에 추가가 가능한 이상이다.
- 예 ) 강의를 아직 수강하지 않은 새로운 학생을 삽입할 경우 강의코드 속성에는 null 값이 들어가야 한다.



### 갱신 이상

- 중복된 데이터 중 일부만 수정되어 데이터 모순이 일어나는 이상이다.



### 삭제 이상

- 어떤 정보를 삭제하면 유용한 다른 정보까지 삭제되어버리는 이상이다.

[이상](https://kosaf04pyh.tistory.com/294)



## 정규화

테이블 간 중복된 데이터를 허용하지 않게 만드는 것이다.

중복된 데이터를 허용하지 않음으로써 무결성을 유지할 수 있으며 DB의 저장 용량을 줄일 수 있다.

즉, 이상을 제거하는 과정이다.



### 제 1 정규화

- 테이블의 컬럼이 원자값(하나의 값)을 갖도록 테이블을 분해하는 것이다.
- 즉, 각 테이블은 2개 이상의 값을 가지면 안되며 2개 이상일 때에는 레코드를 2개 이상으로 나눠주어야 한다.



### 제 2 정규화

- 제 1 정규화를 진행한 테이블에 대해 완전 함수 종속을 만족하도록 테이블을 분해하는 것이다.
- 완전 함수 종속이란 기본키의 부분집합이 결정자가 되어선 안된다는 것이다.
- 즉, 부분 함수 종속을 없애는 것이다.
- 기본키가 복합키일 때 부분키가 결정자가 되는 상황을 2개의 테이블로 나눈뒤 외래키로 참조하는 것이다.



### 제 3 정규화

- 제 2 정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블을 분해하는 것이다.
- 이행적 종속은 A -> B, B -> C, A -> C 가 성립하는 것을 말한다. 즉, A는 B를 결정하고 있고 B는 C를 결정하고 있는 것이다. 이것을 A,B 테이블, B,C 테이블로 분해해야 한다. 그리고 외래키로 참조해야 한다.

[정규화](https://mangkyu.tistory.com/110)



## 뷰

사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된 이름을 가지는 가상 테이블이다.

- 뷰는 저장장치 내에 물리적으로 존재하지 않지만 사용자에게 있는 것처럼 간주된다. 뷰는 데이터 딕셔너리 테이블에 뷰에 대한 정의만 저장되지 디스크 공간에 할당되지 않는다.
- 뷰는 데이터 보정작업, 처리과정 시험 등 임시적인 작업을 위한 용도로 활용된다.
- 뷰는 조인문의 사용 최소화로 사용상의 편의성을 최대화 한다.
- 기본 테이블의 기본키를 포함한 속성 집합으로 뷰를 구성해야하지만 삽입, 삭제, 갱신, 연산이 가능하다.
- 뷰나 기본 테이블이 삭제되면 그 뷰나 테이블을 기초로 정의된 다른 뷰도 자동으로 삭제된다.
- 뷰는 ALTER문 사용이 불가능하다. 그래서 필요할 경우 삭제한 후 재생성한다.
- RESTRICT : 뷰를 다른 곳에서 참조하고 있으면 삭제가 취소된다.
- CASCADE : 뷰를 참조하는 다른 뷰나 제약 조건까지 모두 삭제된다. 참조 무결성을 위해 존재한다. 즉, PK, FK 간의 관계가 항상 유효하도록 관리하는 것으로 PK를 참조하는 FK가 있다면 해당 PK는 수정과 삭제가 불가능하다.
- 장점
  - 논리적 데이터 독립성을 제공한다.
  - 동일 데이터에 대해 동시 여러 사용자의 요구를 들어서 지원할 수 있다.
  - 접근 제어를 통한 자동 보안이 제공된다.
- 단점
  - 독립적인 인덱스를 가질 수 없다.
  - ALTER 사용 불가능하다.
  - 뷰로 구성된 내용에 대한 삽입, 삭제, 갱신, 연산에 제약이 따른다.

[뷰](https://coding-factory.tistory.com/224)



## ERD

개체-관계 모델로 테이블간 관계를 설명해주는 다어그램이며 이를 통해 DB 구조를 한눈에 파악할 수 있습니다.



### Entity

- 실세계에서 독립적으로 존재하는 장소, 클래스 또는 객체이다.
- 테이블을 구성하는 객체 구성성분이다.



### Entity Type

- 유사한 특성을 가진 엔티티 집합이다.



### Entity Set

- 데이터베이스에 설정된 엔티티는 특정 엔티티 유형을 갖는 엔티티의 집합을 나타낸다.



## Index

추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조이다.

책의 색인과 같은 역할을 하는 것이다.

- 인덱스는 하나 혹은 여러 개의 컬럼을 이용하여 생성할 수 있다.

- 인덱스가 없다면 전체를 탐색하는 Full Scan을 수행해야 한다.
- 장점
  - 테이블을 조회하는 속도와 성능을 향상시킬 수 있다.
  - 전반적인 시스템의 부하를 줄일 수 있다.
- 단점
  - 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요하다.
  - 인덱스를 관리하기 위해 추가 작업이 필요하다.
  - 인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과를 볼 수 있다. (UPDATE, DELETE가 많은 테이블에는 적용하지 않는 것이 좋다. 인덱스를 삭제하지 않고 '사용하지 않음' 처리를 하기 때문이다)
- 사용하면 좋은 경우
  - 규모가 작지 않은 테이블
  - INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
  - JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼
  - 데이터의 중복도가 낮은 컬럼
- 인덱스는 B+Tree를 이용한다.
  - 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘이다.
  - SELECT 질의의 조건에는 부등호 연산도 포함되는데 해시 테이블을 사용하게 되면 연산이 아닌 부등호 연산의 경우에 문제가 발생한다. 동등 연산에 특화된 해시 테이블은 데이터베이스의 자료구조로 적합하지 않다.

[인덱스](https://mangkyu.tistory.com/96)



## Index Hunting

인덱스 수집을 향상시켜 데이터베이스 성능뿐만 아니라 쿼리 성능을 향상시키는 프로세스이다.

쿼리 성능과 데이터베이스 속도를 향상시키는데 도움이 되는 인덱스 수집을 강화하는 프로세스이다.

- 쿼리 향상 방법
  - 쿼리 최적화 프로그램을 사용하여 워크로드와 쿼리를 조정한다.
  - 인덱스 및 쿼리 배포의 성능 및 효과를 관찰한다.



## Checkpoint

모든 로그가 저장 디스크에 영구적으로 저장되고 일관성이 없는 지점을 선언한다. 충돌이 발생하면 시스템이 검사 점에서 다시 시작할 수 있으므로 작업량과 시간이 절약된다.

데이터베이스 엔진이 예기치 않은 종료 또는 충돌 후 복구과정에서 로그에 포함된 변경 내용의 적용을 시작할 수 있는 알려진 올바른 지점을 만드는 것이다.

- 장애 발생 시 체크포인트 이전의 기록은 제외하고 체크포인트 이후에 처리된 내용에 대해서만 회복 작업을 수행한다.



## Trigger

특정 테이블에 INSERT, DELETE, UPDATE 같은 DML 문이 수행 되었을 때 데이터베이스에서 자동으로 동작하도록 작성된 프로그램이다.

즉, 사용자가 직접 호출하는 것이 아닌 데이터베이스가 자동적으로 호출하는 것이다. 이벤트 발생 시 자동으로 실행되는 명령 세트이다.

- 예 ) 일자별판매집계테이블을 생성하고 사용자가 주문을 하면 자동으로 일자별판매집계테이블에도 업데이트 되어 관리자가 쿼리를 모든 데이터에 대해 작성하지 않아도 빠르게 실시간으로 확인할 수 있다.

[트리거](https://limkydev.tistory.com/154#recentComments)



## 저장 프로시저

일련의 쿼리를 마치 하나의 함수처럼 실행하기 위한 쿼리의 집합이다.

특정 로직의 쿼리를 함수로 만들어 놓아서 재사용하는 것이다.

- 장점
  - 하나의 요청으로 여러 SQL문을 실행할 수 있다.
  - 옵티마이저가 구문을 분석하고 실행 가능한 코드로 바꾸는데 비용이 많이 드는데 그것을 절약할 수 있다.
  - 데이터베이스 마이그레이션 시 저장 프로시저만 바꾸면 되며 서버 코드는 바꾸지 않아도 된다.
  - 유지보수가 쉬워진다.
- 단점
  - 처리 성능이 낮다.
    - 문자나 숫자 연산에 저장 프로시저를 사용한다면 오히려 C, JAVA보다 성능이 느리다.
  - 디버깅이 어렵다.
  - DB 확장이 힘들다.
    - 서비스 사용자가 많아져서 서버 수를 늘려야할 때, DB 수를 늘리는 것이 어렵다.
    - WAS의 수를 늘려서 대부분 로직은 WAS에서 처리하는 것이 좋다.



## Deadlock

트랜잭션에서 UPDATE할 경우 읽기 일관성을 유지하기 위해 행레벨에서 Lock을 걸어버리는데, 다른 트랜잭션에서 UPDATE 작업을 할 수 없도록 하는 것이다.



### Lock

- 데이터의 일관성을 보장하는 방법이다.
- 잠금은 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 한 지점에는 하나의 커넥션만 변경할 수 있게 해주는 역할을 한다.
- Shared Lock (공유 Lock)
  - 읽을 때 사용한다.
  - 원하는 데이터에 lock을 걸었지만 다른 세션에서 읽을 수 있다.
  - 공유 lock을 설정한 경우 추가로 공유 lock을 설정할 수 있지만 배타적 lock은 설정할 수 없다. 즉, 내가 보고 있는 데이터는 다른 사용자가 볼 수 있지만 변경할 수는 없다.
- Exclusive Lock (배타적 Lock)
  - 데이터를 변경할 때 사용한다.
  - 해당 Lock이 해제되기 전까지는 다른 공유 Lock, 배타적 Lock을 설정할 수 없다. 즉, 읽기, 쓰기 모두 불가능 하다는 뜻이다.



### Blocking

- 블로킹은 Lock들의 경합(Race Condition)이 발생하여 특정 세션이 작업을 진행하지 못하고 멈춰 선 상태를 의미한다. 공유 Lock과 배타적 Lock 또는 배타적 Lock과 배타적 Lock끼리 블로킹이 발생할 수 있다.
- 해결 방법은 Transaction commit 또는 Rollback 뿐이다.



### Deadlock

- 두 개 이상의 트랜잭션이 특정 자원(테이블 또는 레코드)의 Lock을 획득한 채 다른 트랜잭션이 소유하고 있는 잠금을 요구하면 아무리 기다려도 상황이 바뀌지 않는 상태이다.
- 즉, 서로 각각 하나씩 잠구고 있는데 서로 상대방의 자원도 탐내서 작업 진행이 안되는 것이다.

- 예방 기법
  - 트래잭션이 실행되기 전에 필요한 모든 자원을 Lock한다.
  - SET LOCK_TIMEOUT문을 통해 일정 시간이 지나면 쿼리를 취소한다.
- 회피 기법
  - 자원을 할당할 때 시간 스탬프(Time Stamp)를 활용하여 교착 상태가 일어나지 않도록 회피하는 방법이다.
  - Wait-Die
    - 트랜잭션 A가 트랜잭션 B에 의해 잠금된 데이터를 요청할 때 트랜잭션 A이 먼저 들어온 트랜잭션이라면 대기(Wait)한다.
    - 트랜잭션 A가 나중에 들어온 트랜잭션이라면 포기(Die)하고 나중에 다시 요청한다.
  - Wound-Wait
    - 트랜잭션 A가 트랜잭션 B보다 먼저 들어온 트랜잭션이라면 데이터 선점(Wound)한다.
    - 트랜잭션 A가 트랜잭션 B보다 나중에 들어온 트랜잭션이라면 대기(Wait)한다.

- Deadlock 빈도 낮추는 방법
  - 트랜잭션 커밋을 자주한다.
  - 정해진 순서로 테이블에 접근한다.
  - 읽기 잠금 획득의 사용을 피한다(SELECT ~ FOR UPDATE).
  - 인덱스 설계 (UPDATE시 인덱스를 타지 않으면 테이블 전체에 Lock이 걸릴 수 있다)한다.
- 낙관적 병행 제어 방법
  - 트랜잭션이 실행되는 동안에는 검사를 수행하지 않고 트랜잭션이 커밋된 후에 데이터에 문제가 있다면 rollback한다.
  - 판독 -> 확인 -> 기록 단계를 따른다. 확인 단계를 성공적으로 거친 트랜잭션만 기록 단계를 수행한다.

[데이터베이스 Deadlock1](https://jaehoney.tistory.com/162?category=887684)

[데이터베이스 Deadlock2](https://velog.io/@yrkim/Database-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-deadlock)



## NoSQL

Not Only SQL로 데이터 및 테이블 간 관계를 정의하지 않습니다.

- 정해진 스키마가 없다.
- 일반적으로 테이블간 조인을 하지 않는다.
- 수평적 확장성(Scale-out)을 RDBMS보다 쉽게 할 수 있다.



### Key-Value Database

- 데이터가 key, value 쌍으로 저장된다.
- 어떠한 데이터라도 담을 수 있다.
- 간단한 API를 제공하는 만큼 질의의 속도가 굉장히 빠르다.
- 예 ) Redis, Amazon DynamoDB



### Document Database

- 데이터가 key, document 형태로 저장된다.
- Key-Value와 차이점은 Value가 계층적인 형태의 도큐먼트로 저장된다는 것이다.
- 도큐먼트는 객체와 유사하며 하나의 단위로 취급되어 저장된다. 즉, 하나의 객체를 여러 개의 테이블에 나눠 저장할 필요가 없어진다는 뜻이다.
- 객체를 도큐먼트 형태로 바로 저장 가능하기 때문에 객체-관계 매핑이 필요하지 않다.
- 도큐먼트는 질의의 결과가 JSON이나 XML 형태로 출력되기 때문에 사용 방법이 RDBMS에서의 질의 결과를 사용하는 방법과 다르다.
- 예 ) MongoDB



### RDBMS vs NoSQL

- RDBMS
  - 장점
    - 정해진 스키마에 따라 데이터를 저장하여야 하므로 명확한 데이터 구조를 보장한다.
    - 관계는 각 데이터를 중복없이 한 번만 저장할 수 있다.
  - 단점
    - 관계로 인해 시스템이 커질 경우 join문이 많은 복잡한 쿼리 탄생한다.
    - 성능 향상을 위해 Scale-up만 지원한다.
    - 스키마로 인해 데이터가 유연하지 않다.
- NoSQL
  - 장점
    - 스키마가 없기 때문에 유연하며 자유로운 데이터 구조를 가질 수 있다. 즉, 언제든 저장된 데이터를 조정하고 새로운 필드를 추가할 수 있다.
    - 데이터 분산이 용이하며 성능 향상을 위한 Scale-up 뿐만이 아닌 Scale-out 또한 가능하다.
  - 단점
    - 데이터 중복이 발생할 수 있으며 중복된 데이터가 변경될 경우 수정을 모든 컬렉션에서 수행해야 한다.
    - 스키마가 존재하지 않기에 명확한 데이터 구조를 보장하지 않으며 데이터 구조 결정이 어려울 수 있다.



### RDBMS & NoSQL 사용 경우

- RDBMS
  - 데이터 구조가 명확하며 변경 될 여지가 없으며 명확한 스키마가 중요한 경우 사용하는 것이 좋다.
  - 중복된 데이터가 없어(데이터 무결성) 변경이 용이하기 때문에 관계를 맺고 있는 데이터가 자주 변경이 이루어지는 시스템에 적합하다.

- NoSQL
  - 정확한 데이터 구조를 알 수 없고 데이터가 변경 및 확장이 될 수 있는 경우에 사용하는 것이 좋다.
  - UPDATE가 많이 이루어지지 않는 시스템이 좋으며 Scale-out이 가능하다는 장점을 활용해 막대한 데이터를 저장해야 해서 이러한 시스템에 적용하는 것이 좋다.

[NoSQL](https://khj93.tistory.com/entry/Database-RDBMS%EC%99%80-NOSQL-%EC%B0%A8%EC%9D%B4%EC%A0%90)



## Delete & Drop & Truncate

- DELETE
  - 데이터는 지우지만 테이블 용량은 줄어들지 않고 원하는 데이터만 골라서 지울 수 있다.
  - 삭제 후 되돌릴 수 있다. (rollback 가능하다)
- TRUNCATE
  - 전체 데이터를 한번에 삭제하는 방식이다.
  - 테이블 용량이 줄어들고 인덱스 등도 삭제되지만 테이블은 삭제할 수 없고 데이터만 삭제하며 한꺼번에 다 지워야 한다.
  - 삭제 후 되돌릴 수 없다.
- DROP
  - 테이블 자체를 완전히 삭제하는 방식(공간, 인덱스, 객체 모두 삭제)이다.
  - 삭제 후 되돌릴 수 없다.



## ORM

객체와 관계형 데이터베이스의 데이터를 자동으로 매핑하는 것을 뜻한다.

- 객체 지향 프로그래밍은 클래스를 사용하고 관계형 데이터베이스는 테이블을 사용한다.
- 객체 모델과 관계형 모델간 불일치가 존재하는데 이때 ORM을 통해 객체 간의 관계를 바탕으로 SQL을 자동으로 생성하여 불일치를 해결한다.

- 장점
  - 객체 지향적인 코드로 인해 더 직관적이고 비즈니스 로직에 더 집중할 수 있게 한다.
  - 재사용성 및 유지보수의 편리성이 증가한다.
  - DBMS에 대한 종속성이 줄어든다.
    - 대부분 ORM 솔루션은 DB에 종속적이지 않다.
- 단점
  - ORM이 모든 것을 해결하지는 않으며 적절하게 native query를 사용할 수 있어야 한다.
    - 튜닝을 위해서 사용해야 할 수 있다.
  - 이미 프로시저가 많은 시스템에서는 다시 객체로 바꿔야 하는데 생산성 저하나 리스크가 발생한다.



## 쿼리 튜닝

- WHERE 조건에는 인덱스 컬럼을 모두 사용한다.
  - 인덱스로 설정한 컬럼은 모두 사용한다.
- 인덱스 컬럼에 사용하는 연산자는 가급적 동등 연산다(=)를 사용한다.
  - LIKE와 같은 연산자를 사용하면 인덱스 효율이 떨어진다.
  - IS NULL, IS NOT NULL, NOT IN 등이 사용되었을 경우에도 마찬가지이다.
- 인덱스 컬럼은 변형하여 사용하지 않도록 한다.
  - WHERE 조건에 인덱스 컬럼을 사용했고 동등 연산자를 사용했다 하더라도 인덱스 컬럼에 변형을 가하게 되면 인덱스를 사용하지 못한다.
  - 예 ) SUBSTR()

- OR 보다는 AND를 사용한다.
  - 옵티마이저의 OR-Expansion 처리는 OR 연산자로 연결된 쿼리를 UNION ALL로 변환하므로 OR 보다는 AND를 사용해야 성능 좋은 쿼리를 작성할 수 있다.
- 그루핑 쿼리를 사용할 경우 가급적 HAVING 보다는 WHERE 절에서 데이터를 필터링한다.
  - 그루핑 쿼리 처리순서는 WHERE 조건이 먼저 처리되므로 가급적 필터링 할 대상은 WHERE 조건에서 처리할 수 있게 쿼리를 작성할 수 있도록 한다.
  - HAVING 절은 이미 WHERE 절에서 처리된 로우들을 대상으로 조건을 감시하기 때문에 좋은 성능을 발휘하기가 힘들다.
- DISTINCT는 가급적 사용하지 않는다.
  - DISTINCT는 키워드 내부적으로 정렬 작업을 수반하기 때문에 꼭 필요한 경우가 아니라면 사용하지 않는다.
- IN, NOT IN 대신 EXISTS 와 NOT EXISTS를 사용한다.
  - IN 이나 NOT IN 연산자 보다는 EXISTS 나 NOT EXISTS를 사용하는 것이 더 좋은 성능을 발휘한다.
- ORM은 좋지 않은 쿼리를 만들어내기 때문에 저장 프로시저를 이용하는 것이 좋다.





튜닝

회복기법





[데이터베이스 면접 질문1](https://hyonee.tistory.com/41)

[데이터베이스 면접 질문2](https://dev-coco.tistory.com/158)