# 개발 방법론



## TDD(테스트 주도 개발)

- 반복 테스트를 이용한 소프트웨어 방법론으로 작은 단위의 테스트 케이스를 작성하고 이를 통과하는 코드를 추가하는 단계를 반복하여 구현한다.
- 애지일 방법론 중 하나인 eXtream Programming기반 설계
  - XP - 미래에 대한 예측을 최대한 하지 않고, 지속적으로 프로토타입을 완성하는 애자일 방법론 중 하나이다. 추가 요구사항이 생기더라도 실시간 반영가능
- 실패하는 테스트코드 작성 -> 테스트 코드 성공을 위한 실제 코드 작성 -> 리펙토링 실행

- TDD 이용안하는 일반적인 개발방식은 오히려 나중에 발생하는 오류 해결로 테스트 비용이 증가하며 오히려 프로젝트의 완성시간이 단축된다. but 일반적으로 시간 10~30%느리며 납기일 준수가 목적인 SI프로젝트는 잘 이용안한다.
- 객체 지향적인 코드생산 - 모듈화, 재설계 시간을 단축시킬 수 있는 코드, 디버깅 시간이 단축되는 코드
- 테스트 코드 작성 -> 테스트 코드 실행(이때 테스트 성공하면 구현하지도 않은 부분의 코드의 성공이므로 버그 찾아야 한다) -> 실패한 테스트 코드를 위한 최소한 코드 구현 -> 코드 리펙토링



## BDD(행동 주도 개발)

- TDD와 비슷하지만 테스트 자체가 아닌 비즈니스 요구사항에 집중하여 테스트 케이스를 개발한다.
- 즉, 테스트 케이스 자체가 요구사항이 되도록 개발한다.
- TDD 결합으로 시나리오 테스트까지 한다(어디서부터 테스트, 어떤것을 테스트, 얼만큼 테스트 등).
- 시나리오는 어디서부터 테스트를 시작할지, 어떤 것을 테스트하고 어떤 것을 하지 않을지, 한 번에 얼마만큼을 테스트할지, 테스트에 어떤 이름을 붙일지, 테스트가 왜 실패했는지 등에 대한 고민을 해결해준다.
- "should do something"라는 식의 문장으로 작성해 "행위"를 위한 테스트에 집중
- TDD보다는 좀 더 큰 단위로 개발을 진행한다.
- 코드를 작성하기 전에 코드가 수행할 행위(Behavior)(시나리오)에 대한 명세를 먼저 작성해야 한다.



## DDD(도메인 주도 개발)

- 순수한 도메인의 모델과 로직에 집중하는 것이다.
- **즉, 일반적으로 많이 사용하는 데이터 중심의 접근법을 탈피하여 순수한 도메인의 모델과 로직에 집중한다.**
- 상호가 이해할 수 있도록 모든 문서와 코드가 동일한 표현과 단어로 구성되게 한다.
- **분석 작업과 설계 그리고 구현까지 통일된 방식으로 커뮤니케이션 가능하다.**
- 도메인 모델부터 코드까지 항상 함께 움직이는 구조의 모델을 지향한다.
- 도메인이란, SW로 해결하고자 하는 문제의 영역, 즉 만들고자 하는 서비스를 잘게 쪼개놓은 단위.

[TDD BDD DDD](https://m.blog.naver.com/rkdudwl/221973507455)



# 객체 지향 설계



## SOLID

### SRP

- 단일 책임 원칙으로 모든 클래스는 각각 하나의 책임을 가져야 한다. 클래스는 그 책임을 완전히 캡슐화 해야한다. 

### OCP

- 개방-폐쇄 원칙으로 확장에는 열려있고 수정에는 닫혀있는 기존의 코드를 변경하지 않으면서(closed) 기능을 추가할 수 있도록(open) 설계 되어야 한다는 원칙이다(인터페이스화 같다).

### LSP

- 리스코프 치환 원칙으로 자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있다는 원칙이다. 즉, 부모 클래스가 들어갈 자리에 자식 클래스를 넣어도 계획대로 잘 작동해야 한다(다형성 고려 인터페이스).

### ISP

- 인터페이스 분리 원칙으로 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다. 하나의 일반적인 인터페이스보다 여러개의 구체적인 인터페이스가 낫다.

### DIP

- 의존 역전 원칙으로 의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운 것, 거의 변화가 없는 것에 의존하라는 것이다. 한마디로 구체적인 클래스보다 인터페이스나 추상 클래스와 관계를 맺으라는 것이다.

[SOLID1](https://hckcksrl.medium.com/solid-%EC%9B%90%EC%B9%99-182f04d0d2b)

[SOLID2](https://dev-momo.tistory.com/entry/SOLID-%EC%9B%90%EC%B9%99)



# Agile

- 빠르게 취하고 낭비없게 만든는 다양한 방법론을 말한다.
- 앞을 예측하지 않고 일정한 주기를 가지고 계속 검토해 나가며 필요할 때마다 요구사항을 더하고 수정하는 방식을 한다.
- 경험 기반 프로세스이며 적시(just-in-time)설계
- 코드강조
- 팀워크 중시
- 장점
  - 프로젝트 계획에 걸리는 시간 최소화
  - 버그를 쉽고 빠르게 발견 가능
  - 수정과 변경에 유연
  - 즉각적인 피드백으로 프로토타입 모델 빠른 출시
- 단점
  - 확정되지 않은 계획 및 요구사항으로 인한 반복적인 유지보수 작업이 많다.
  - 개인이 아닌 팀이 중심이어서 공통으로 해야할 작업이 많다(회의).

## Scrum

- 스프린트 - 크지 않은 태스크를 적당한 기간동안 집중해서 전력질주하듯 업무를 수행하는 것이다. 스크럼 내부에 있으며 계획 회의 부터 제품 리뷰까지 기간이 1스프린트이다.
- 스프린트 백로그 - 스프린트 목표에 도달하기 위해 필요한 작업 목록
- 스크럼 회의 - 날마다 진행되는 미팅(어제한일, 오늘할일, 장애현상)
- 제품 책임자(product owner) - 제품 백 로그를 정의하여 우선순위를 정해 준다.
- 스크럼 마스터(Scrum Master) - 일반적인 관리를 수행하는 프로젝트 관리자들과는 달리 팀원을 코칭하고 프로젝트의 문제 상황을 해결하는 역할을 하며, 제품 책임자는 스프린트 목표와 백로그 등의 결정에 있어 중심이 되는 상위 관리자이다.



# Thread Safe

Multi Thread 프로그래밍에서 여러 Thread로부터 어떤 method나, variable, object에 동시에 접근이 이루어져도 프로그램의 실행에 문제가 없는 것을 말한다.

- HashMap 대신 ConcurrentHashMap 사용
- Long 대신 AtomicLong 사용
- StringBuilder 보다 StringBuffer이 Thread Safe 하다.
- 빈에 변할 수 있는 변수가 있다면 Thread Safe하지 않다. 이때 지역변수로 사용하거나 scope을 prototype으로 하여 singleton이 아닌 새로운 객체 생성되게 한다. 아니면 읽기 전용으로 만들어서 setter을 삭제해야 한다.

[Thread Safe](https://velog.io/@cateto/Java-Thread-Safe%EB%9E%80)



# AOP & Filter & Interceptor



## AOP

AOP는 관점 지향 프로그래밍으로 객체를 추상화하여 모듈화 하는 것이다.

- 주소가 아닌 파라미터, 어노테이션 등으로 대상 설정이 가능하다.
- 공통처리에 사용되며 로깅이나 실행시간 체크 시 이용한다.



## Filter

자바 표준을 활용하며 웹 컨테이너가 관리한다.

- Dispatcher Servlet 전에 호출된다.
- 보안, 인증, 인가, 압축, 인코딩 시 사용된다.



## Interceptor

스프링이 제공하는 기술이며 스프링 컨테이너가 관리한다.

- Dispatcher Servlet 이후에 호출된다.
- 클라이언트의 요청과 관련되어 전역적으로 처리해야 하는 작업들을 처리해야 한다.
- 컨트롤러로 넘겨주기 위한 정보를 가공한다.

[AOP & Filter & Interceptor](https://www.saichoiblog.com/springboot-filterling/)





# MSA

단일 프로그램을 각 컴포넌드 별로 나누어 작은 서비스의 조합으로 구축하는 방법이다. 서비스를 모듈화 한다고 생각하면 된다.



## Monolithic

전체 어플리케이션이 하나로 되어있는 구조이다.

![leh_3](http://clipsoft.co.kr/wp/wp-content/uploads/2020/06/leh_3.png)

- 하나의 덩어리로 된 구조이다.
- 각 컴포넌트들이 함수로 호출되기 때문에 성능에 제약이 덜하고 운영 관리가 용이하다.
- 작은 볼륨의 시스템을 개발할 때는 유용하지만 시스템이 커지기 시작하고 여러 컴포넌트들이 더해지면 문제가 발생한다.
- 단점
  - 빌드 / 테스트 시간이 길어진다.
    - 작은 수정에도 시스템 전체를 빌드해야 하며 테스트 시간도 길어진다.
    - CI / CD 시 오래 걸린다.
  - 선택적 확장이 불가능하다.
    - 이벤트로 인해 서비스 접속량이 폭증할 경우 프로젝트 전체를 확장해야 한다.
  - 하나의 서비스가 모든 서비스에 영향을 준다.
    - 이벤트 서비스에 트래픽이 몰려 해당 서버가 죽게 된다면 다른 모든 서비스 역시 마비된다.



## MSA

작은 서비스를 기준으로 구성되는 구조이다. 서비스 지향적 아키텍쳐 스타일이다.

![leh_4](http://clipsoft.co.kr/wp/wp-content/uploads/2020/06/leh_4.png)

- 장점

  - 각 컴포넌트는 서비스 형태로 구현되고 API를 이용하여 타 서비스와 통신한다.
  - 각 서비스는 독립된 서버이므로 독립된 배포를 한다.
  - 각 컴포넌트가 독립된 서비스로 개발되어 있기 때문에 부분적인 확장이 가능하다(이벤트 서버만 스케일링).

- 단점

  - 모놀리틱 아키텍처는 서비스간 호출이 하나의 프로세스 내에서 이루어지기 때문에 속도가 빠르지만 MSA 경우 서비스간 호출을 API 통신을 이용하기 때문에 속도가 느리며 통신에 사용하기 위해 값을 데이터 모델로 변환시켜주는 오버헫가 발생하기도 한다.

- 특징

  - 데이터분리

    - 데이터 저장 시 하나의 DB에 중앙 집중화를 하지 않고 서비스 별 별도의 데이터 베이스를 사용한다.
    - 같은 DB를 사용하더라도 나누어서 사용하게 된다.
    - 장점
      - 데이터가 분산되어있기 때문에 다른 서비스 컴포넌트에 대한 의존성이 없이 서비스를 독립적으로 개발 및 배포 / 운영 할 수 있다.
    - 단점
      - 다른 컴포넌트의 데이터를 API통신을 통해 가져와야 하기 때문에 성능상 문제가 발생할 수 있다.
      - 트랜잭션으로 쿼리를 묶을 수 없는 문제가 발생한다.

  - API Gateway

    - MSA의 문제점 중 하나는 각 서비스가 다른 서버에 분리 배포되어있기 때문에 서버 URL이 각기 다를 수 밖에 없다.
    - 이때 API Gateway는 API 서버 앞 단에서 모든 API 서버들의 End-Point를 단일화하여 묶어주는 역할을 한다.
    - 거미줄처럼 복잡한 서비스간의 API호출 구조도 단순화 시킨다.
    - 라우팅, 로드밸런싱, 인증 역할도 수행한다.

  - 팀의 변화

    - 기존 모놀리틱의 팀 모델은 역할 별로 나누어진 모델로 팀을 구분했다.
    - 이러한 팀 모델은 인력 관리와 운영에 유연성을 부여하지만 팀 간의 커뮤니케이션이 원활하지 않고 협업에 걸리는 시간이 지연되는 경우가 많다.
    - 기획, UX, 개발, 인프라 운영 팀이 존재하며 각각 독립적이다.

    ![leh_5](http://clipsoft.co.kr/wp/wp-content/uploads/2020/06/leh_5.png)

    - MSA에서는 서비스 별로 팀을 나누고 서비스 기획에서부터 설계 개발 운영이 팀 내에서 이루어지기 때문에 다른 팀에 대한 의존성이 사라진다.
    - 역할별 요청과 피드백이 빨라지고 유연하고 지속적인 운영과 개발이 함께된다.
    - 하지만 각 팀의 역할 담당자는 기본적인 업무 성숙도를 가지고 있어야 하며 개발팀은 운영팀의 인프라 핸들링까지 해야한다(AWS같은 클라우드 발달로 가능해졌다).

    ![leh_6](http://clipsoft.co.kr/wp/wp-content/uploads/2020/06/leh_6.png)

[MSA](http://clipsoft.co.kr/wp/blog/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98msa-%EA%B0%9C%EB%85%90/)



# Message Queue

메시지들을 큐라는 자료구조에 담아서 관리한다는 의미이다.



## MOM

"메시지 지향 미들웨어" 라고 부른다.

응용 소프트웨어 간의 데이터(비동기 메시지) 통신을 위한 소프트웨어이다.

![img](https://blog.kakaocdn.net/dn/bzojLH/btrcFV6Bj5V/cgVBm4FFu840FgA9b0Cd9k/img.png)

- 메시지 지향 미들웨어는 메시지를 전달하는 과정에서 보관하거나 라우팅 및 변환할 수 있다는 장점이 있다.
  - 보관 : 메시지의 백업을 유지함으로써 지속성을 제공, 덕분에 송수신 측은 동시에 네트워크 연결을 유지할 필요가 없다.
  - 라우팅 : 미들웨어 계층 자신이 직접 메시지 라우팅이 가능하기 때문에 하나의 메시지를 여러 수신자에게 배포가 가능해진다(멀티캐스트).
  - 변환 : 송수신 측의 요구에 따라 메시지를 변환할 수 있다.
- 단점
  - 아케텍처에 외부 구성 요소인 메시지 전송 에이전트가 필요, 일반적으로 새로운 요소를 추가할 경우 시스템 성능이 저하되고 신뢰성이 떨어진다.
  - 시스템이 복잡해지기 때문에 관리가 어렵고 비용이 발생한다.
  - 어플리케이션 간의 통신은 본질적으로 동기지만 메시지 기반 통신은 본질적으로 비동기이기 때문에 메커니즘 불일치가 발생한다.



## Message Queue

메시지 큐는 메시지 지향 미들웨어(MOM)를 구현한 시스템으로 프로그램(프로세스) 간의 데이터를 교환할 때 사용하는 기술이다.

![img](https://blog.kakaocdn.net/dn/Ngglq/btrcBzwwxTZ/q8QoaXArd36vlklhu85KT0/img.png)

- 장점
  - **비동기(Asynchronous)** : 데이터를 수신자에게 바로 보내지 않고 큐에 넣고 관리하기 때문에 나중에 처리 가능
  - **비동조(Decoupling)** : 애플리케이션과 분리할 수 있기 때문에 확장이 용이해짐
  - **탄력성(Resilience)** : 일부가 실패하더라도 전체에 영향을 주지 않음
  - **과잉(Redundancy)** : 실패할 경우 재실행 가능
  - **보증(Guarantees)** : 작업이 처리된 걸 확인할 수 있음
  - **확장성(Scalable)** : N:1:M 구조로 다수의 프로세스들이 큐에 메시지를 보낼 수 있음
- 메시지 큐는 대용량 데이터를 처리하기 위한 배치 작업, 채팅 서비스, 비동기 데이터 처리 시 사용한다.
- 다량의 요청을 바로 서버로 보내지 않고 메시지 큐에 보관하고 서버 측에서는 처리하는데 이상 없을 정도의 요청들만 메시지 큐에서 가져와서 처리하여 서버 부담을 줄인다.
- RabbitMQ, ActiveMQ는 신뢰성 있는 메시지 브로커가 필요한 경우 사용하며 Kafka는 처리량이 많은 분산 메시징 시스템에서 사용된다.

[Message Queue](https://sorjfkrh5078.tistory.com/291)



# Cloud



## Public Cloud

퍼블릭 클라우드는 리소스를 클라우드 서비스 공급자가 소유하고 인터넷을 통해 제공하는 클라우드이다.

- 하드웨어, 소프트웨어 지원 인프라를 공급자가 소유하고 관리한다.
- 여기서 공급자는 외부 기업 및 데이터 센터이다.
- Pay as you go 정책을 따른다.
- Ex) AWS, Azure, GCP
- 장점
  - 비용절감
    - 하드웨어 또는 소프트웨어를 구매할 필요가 없으며, 사용한 서비스의 요금만 지불하면 된다.
  - 유지관리 불필요
    - 서비스 공급자가 유지 관리를 제공한다.
  - 무제한에 가까운 스케일링 기능
    - 주문형 리소스를 사용하여 비즈니스 요구 사항을 충족할 수 있다.
- 단점
  - 업체 종속
    - 클라우드 업체가 제공하는 가상 머신, 스토리지, 애플리케이션, 기술 등의 서비스에 종속될 수 있다.



## Private Cloud

프라이빗 클라우드는 하나의 조직에 전용 클라우드 환경을 제공하는 모델이다.

- 프라이빗 클라우드에서는 서비스와 인프라가 항상 프라이빗 네트워크에서 유지 관리되며 하드웨어와 소프트웨어는 조직에서만 전용으로 사용된다.
- 인트라넷 클라우드라고도 불린다.

- Ex) VMware, Openstack
- 장점
  - 유연성 향상
    - 조직에서 특정 비즈니스 요구 사항을 충족하기 위해 클라우드 환경을 사용자 지정할 수 있다.
  - 제어 향상
    - 리소스가 다른 사용자와 공유되지 않으므로 더 높은 수준의 제어 및 개인 정보 보호가 가능하다(보안 우수).
  - 스케일링 성능 향상
    - 온프레미스보다 큰 스케일링 성능을 제공한다.
- 단점
  - 관리비용 및 책임
    - 조직이 관리 비용과 책임을 맡아야하며 인력, 관리, 유지비용이 증가한다.



## Hybrid Cloud

하이브리드 클라우드는 VPN 등의 보안 연결을 통해서 하나 이상의 퍼블릭 클라우드 + 프라이빗 클라우드 환경을 결합하는 방식이다.

- 활용 예
  - 이메일같은 자사의 독자성이 필요없는 서비스는 퍼블릭 클라우드를 이용하고 인사정보나 개인 인증 정보같은 보안성이 필요한 정보는 프라이빗 클라우드에 저장한다.
  - 외부 개발자와 함께 개발할 때는 퍼블릭 클라우드에서 작업하고 개발 결과물은 프라이빗 클라우드로 옮겨서 자사 전용으로 서비스한다.
- 장점
  - 제어
    - 조직이 짧은 대기 시간이 필요한 중요한 자산이나 워크로드를 위한 프라이빗 인프라를 유지 관리할 수 있다.
  - 유연성
    - 필요할 때 퍼블릭 클라우드에서 추가 리소스를 사용할 수 있다.
  - 비용 효율성
    - 퍼블릭 클라우드로 스케일링하는 기능을 통해 필요할 때만 추가 컴퓨팅 성능의 비용을 지불하면 된다.



[Public, Private, Hybrid Cloud1](https://azure.microsoft.com/ko-kr/resources/cloud-computing-dictionary/what-are-private-public-hybrid-clouds/#benefits)

[Public, Private, Hybrid Cloud2](https://owin2828.github.io/devlog/2020/01/10/aws-1.html)

[Public, Private, Hybrid Cloud3](https://ttend.tistory.com/691)



## As a Service

"서비스형(as-a-Service)"는 제 3사에서 클라우드 컴퓨팅 서비스를 제공한다는 의미이다.

- 사용자는 코드, 고객 관계 관리와 같은 더 중요한 업무에 집중할 수 있다.
- 비용이 절감된다.
- 관리가 쉬워진다.
- 스케일링이 가능하다.

![img](https://www.redhat.com/cms/managed-files/iaas-paas-saas-diagram5.1-1638x1046.png)



### IaaS

제 3사가 스토리지와 가상화와 같은 인프라 서비스를 인터넷을 통해 클라우드로 제공하는 것이다.

- 일반적으로 사용하는 클라우드이다.
- 사용자는 운영 체제 및 데이터, 애플리케이션, 미들웨어 및 런타임을 담당하고 제공업체는 사용자가 필요로 하는 네트워크, 서버, 가상화 및 스토리지의 관리와 액세스를 담당한다.
- 장점
  - 필요한 구성 요소만 구매하고 필요에 따라 확장 또는 축소할 수 있는 유연성을 제공한다. 사용자의 재량에 따라 과금되는 경제적인 옵션이다.
  - 개발 및 테스트 환경의 구축 및 제거가 빠르고 유연하다는 장점이 있다. 언제나 스케일링 및 중단 가능하다.
- 단점
  - 제공 업체의 보안 문제 가능성이 있다.
- Ex) AWS, Azure, GCP



### PaaS

제공 업체가 자체 인프라에서 하드웨어와 소프트웨어를 호스팅하고 이러한 플랫폼을 사용자에게 통합 솔루션, 솔루션 스택 또는 인터넷을 통한 서비스로 제공한다.

- 해당 프로세스와 관련된 인프라 또는 플랫폼을 구축하고 유지관리할 필요 없이 사용자가 자체 애플리케이션을 개발, 실행 및 관리할 수 있도록 한다.
- 사용자는 애플리케이션 코드를 작성, 빌드, 관리하지만 소프트웨어 업데이트 또는 하드웨어 유지관리와 같은 번거로움이 사라진다. 빌드 및 배포를 위한 환경이 사용자에게 제공된다.
- 개발자가 프레임워크를 개발하여 지속적으로 웹 기반 애플리케이션을 빌드 및 커스터마이징할 수 있는 방법이다. 개발자는 기본 소프트웨어 구성 요소를 활용하여 자체 애플리케이션을 개발할 수 있으므로 자체적으로 작성해야 하는 코드의 양을 줄일 수 있다.
- Ex) AWS Elastic Beanstalk, Heroku, Red Hat OpenShift



### SaaS

가장 포괄적인 형식의 클라우드 컴퓨팅 서비스로 모든 애플리케이션은 제공업체가 관리하며 웹 브라우저를 통해 제공된다.

- 제공업체가 소프트웨어 업데이트, 버그 수정 및 기타 일반 소프트웨어 유지관리 작업을 처리하며 사용자는 대시보드 또는 API를 통해 애플리케이션을 연결한다.

- 클라우드로 만든 서비스 자체를 제공하는 것으로 google 계정이 지원하는 서비스들을 말한다.
- 현재 개발중인 Fillkie도 SaaS다.
- Ex) Dropbox, Salesforce, Google Apps







[as-a-Service](https://www.redhat.com/ko/topics/cloud-computing/iaas-vs-paas-vs-saas)