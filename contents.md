# 개발 방법론



## TDD(테스트 주도 개발)

- 반복 테스트를 이용한 소프트웨어 방법론으로 작은 단위의 테스트 케이스를 작성하고 이를 통과하는 코드를 추가하는 단계를 반복하여 구현한다.
- 애지일 방법론 중 하나인 eXtream Programming기반 설계
  - XP - 미래에 대한 예측을 최대한 하지 않고, 지속적으로 프로토타입을 완성하는 애자일 방법론 중 하나이다. 추가 요구사항이 생기더라도 실시간 반영가능
- 실패하는 테스트코드 작성 -> 테스트 코드 성공을 위한 실제 코드 작성 -> 리펙토링 실행

- TDD 이용안하는 일반적인 개발방식은 오히려 나중에 발생하는 오류 해결로 테스트 비용이 증가하며 오히려 프로젝트의 완성시간이 단축된다. but 일반적으로 시간 10~30%느리며 납기일 준수가 목적인 SI프로젝트는 잘 이용안한다.
- 객체 지향적인 코드생산 - 모듈화, 재설계 시간을 단축시킬 수 있는 코드, 디버깅 시간이 단축되는 코드
- 테스트 코드 작성 -> 테스트 코드 실행(이때 테스트 성공하면 구현하지도 않은 부분의 코드의 성공이므로 버그 찾아야 한다) -> 실패한 테스트 코드를 위한 최소한 코드 구현 -> 코드 리펙토링



## BDD(행동 주도 개발)

- TDD와 비슷하지만 테스트 자체가 아닌 비즈니스 요구사항에 집중하여 테스트 케이스를 개발한다.
- 즉, 테스트 케이스 자체가 요구사항이 되도록 개발한다.
- TDD 결합으로 시나리오 테스트까지 한다(어디서부터 테스트, 어떤것을 테스트, 얼만큼 테스트 등).
- 시나리오는 어디서부터 테스트를 시작할지, 어떤 것을 테스트하고 어떤 것을 하지 않을지, 한 번에 얼마만큼을 테스트할지, 테스트에 어떤 이름을 붙일지, 테스트가 왜 실패했는지 등에 대한 고민을 해결해준다.
- "should do something"라는 식의 문장으로 작성해 "행위"를 위한 테스트에 집중
- TDD보다는 좀 더 큰 단위로 개발을 진행한다.
- 코드를 작성하기 전에 코드가 수행할 행위(Behavior)(시나리오)에 대한 명세를 먼저 작성해야 한다.



## DDD(도메인 주도 개발)

- 순수한 도메인의 모델과 로직에 집중하는 것이다.
- **즉, 일반적으로 많이 사용하는 데이터 중심의 접근법을 탈피하여 순수한 도메인의 모델과 로직에 집중한다.**
- 상호가 이해할 수 있도록 모든 문서와 코드가 동일한 표현과 단어로 구성되게 한다.
- **분석 작업과 설계 그리고 구현까지 통일된 방식으로 커뮤니케이션 가능하다.**
- 도메인 모델부터 코드까지 항상 함께 움직이는 구조의 모델을 지향한다.
- 도메인이란, SW로 해결하고자 하는 문제의 영역, 즉 만들고자 하는 서비스를 잘게 쪼개놓은 단위.



- 도메인은 "정보와 활용의 영역"을 말하며 어플리케이션 로직의 기준으로 활용될 수 있다. "회원"과 같은 사항이 도메인이다.
- DDD는 데이터가 아닌 도메인을 중심으로 설계하는 것이다.
  - 핵심 도메인과 그 기능에 집중한다.
  - 도메인의 모델을 정교하게 구축한다.
  - 어플리케이션 모델을 발전시키고 새롭게 생기는 도메인 관련 이슈를 해결하기 위해 도메인 전문가와 연락한다.
- Context란 특정 객체 혹은 상황이 벌어지는 주변 환경이다. 피자가 그릇에 있는지 바닥에 있는지에 따라 유료, 무료로 분류되는 것이라고 할 수 있다. Model에 관한 문장은 context 안에서만 이해될 수 있다.
- Strategic Design이란 같은 사물이나 행동 양상이 벌어지는 상황에 집중하여 디자인하는 것이다. 주택을 설계하는 과정이라고 생각하면 된다.
- Domain은 여기서 집 전체를 말한다.
- Subdomain은 domain의 부분 집합으로 헛간, 농장, 수영장 등을 말한다.
- Bounded Context는 subdomain의 문맥적 상황이며 위 context 예시와 유사하다. Context에 대한 구체적인 범위이다.
- Domain Model은 subdomain의 구체적인 형상을 나타낸 것이다. Domain의 특정 양상을 묘사하는 추상화 시스템으로 도메인과 관련된 문제를 해결하는데 사용한다.
- Ubiquitous Language는 domain model을 둘러싼 언어구조를 말하며 팀 전체각 각각의 업무 파트에서 공통적으로 사용될 수 있는 공통된 어휘이다.
- Context Map은 bounded context들 사이의 관계를 말한다.

[TDD BDD DDD](https://m.blog.naver.com/rkdudwl/221973507455)

[DDD2](https://steemit.com/kr/@frontalnh/domain-driven-design)



# 객체 지향 설계



## SOLID

### SRP

- 단일 책임 원칙으로 모든 클래스는 각각 하나의 책임을 가져야 한다. 클래스는 그 책임을 완전히 캡슐화 해야한다. 

### OCP

- 개방-폐쇄 원칙으로 확장에는 열려있고 수정에는 닫혀있는 기존의 코드를 변경하지 않으면서(closed) 기능을 추가할 수 있도록(open) 설계 되어야 한다는 원칙이다(인터페이스화 같다).

### LSP

- 리스코프 치환 원칙으로 자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있다는 원칙이다. 즉, 부모 클래스가 들어갈 자리에 자식 클래스를 넣어도 계획대로 잘 작동해야 한다(다형성 고려 인터페이스).

### ISP

- 인터페이스 분리 원칙으로 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다. 하나의 일반적인 인터페이스보다 여러개의 구체적인 인터페이스가 낫다.

### DIP

- 의존 역전 원칙으로 의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운 것, 거의 변화가 없는 것에 의존하라는 것이다. 한마디로 구체적인 클래스보다 인터페이스나 추상 클래스와 관계를 맺으라는 것이다.

[SOLID1](https://hckcksrl.medium.com/solid-%EC%9B%90%EC%B9%99-182f04d0d2b)

[SOLID2](https://dev-momo.tistory.com/entry/SOLID-%EC%9B%90%EC%B9%99)



# Java 8, Java 11



## Java 8

- 람다 표현식의 탄생
  - 메소드를 하나의 식으로 표현한 것을 말한다. 익명함수라고도 불린다.
  - 가시성이 좋아진다.
- Stream API
  - 컬렉션의 저장 요소를 하나씩 참조해서 람다식으로 처리할 수 있도록 해주는 내부 반복자이다.
- Optional 지원
  - Optional을 통해 null에 대한 참조를 안전하게 할 수 있다.
  - Optional을 통해 NPE를 얻을 상황을 손 쉽게 처리할 수 있다.
- Interface Default Method 탄생
  - 구현을 넣을 수 있으며 굳이 오버라이딩 하지 않아도 된다.

- Garbage Collector
  - Parallel GC 사용한다.



## Java 11

- Javac를 통해 컴파일 하지 않고 바로 java파일 실행 가능하다.
- HTTP Client 기능 표준화로 전반적인 HTTP API 성능 향상했다.
- Garbage Collector
  - G1 GC 사용한다.

[Java 8, Java 11 1](https://livenow14.tistory.com/81)

[Java 8, Java 11 2](https://steady-coding.tistory.com/598)



# Sort

- Arrays.sort()
  - 듀얼 피봇 퀵정렬(Dual-Pivot QuickSort)를 이용한다.
  - 피봇을 2개를 두고 3개의 구간을 만들어 퀵정렬을 한다.
- Collections.sort()
  - Tim 정렬을 이용하며 삽입정렬, 병합 정렬을 결합한 형태이다.
  - Java 7 부터 사용한다.
- Arrays.sort() vs Collections.sort()
  - 참조 지역성 원리 - 동일한 값 또는 해당 값의 근처에 있는 스토리지 위치가 자주 엑세스 되는 특성이다. 캐싱 전략에 영향을 미친다.
  - Array는 연속적인 주소이므로 참조 지역성 원리에 좋다.
  - Collection의 arraylist는 메모리간 인접하지만 linkedlist는 참조 인접성이 좋지 않아서 tim 정렬을 사용한다.
- Heap sort는 최선의 경우 O(n), 최악의 경우 O(nlogn)이지만 참조 지역성이 좋지 않다. 즉 C * nlogn + a 에서 C 가 크게 나온다.
- Merge sort는 인접한 덩어리를 병합하기 때문에 참조 지역성의 원리를 만족한다. 하지만 입력 배열 크기만큼의 메모리를 추가로 사용한다는 단점이 있다.
- Quick sort는 pivot  주변에서 데이터의 위치 이동이 빈번하게 발생하기에 참조 지역성이 좋으며 메모리를 추가로 사용하지 않는다.
- Tim sort는 삽입 정렬로 참조 지역성 원리를 만족하고 병합 정렬로 빅오의 속도를 높이는 것이다.

[Sort1](https://sabarada.tistory.com/138)

[Sort2](https://d2.naver.com/helloworld/0315536)



# Design Pattern

소프트웨어 설계시 이후에 재사용하기 좋은 형태로 설계하는 방법이다.



## 생성

- 싱글톤 패턴
  - 전역 변수를 사용하지 않고 객체를 하나만 생성하도록 하며 생성된 객체를 어디서든 참조할 수 있도록 하는 패턴이다.
- 빌더 패턴
  - 객체를 생성하는 클래스와 표현하는 클래스를 분리하여 동일한 절차에서도 서로 다른 표현을 생성하는 방법을 제공한다.
  - 생성자만 사용할 때 발생할 수 있는 문제를 개선한다.
  - 필수 필드는 생성자로 주입하며 optional한 필드는 빌더 패턴으로 주입한다.



## 구조

- 프록시 패턴
  - 객체를 직접적으로 참조하는 것이 아닌 해당 객체를 대항하는 객체를 통해 대상 객체에 접근하는 방식이다.
  - 연관관계 시 Lazy 가 있다.



## 행위

- 옵저버 패턴
  - 객체들 사이에 1 : N 의 의존관계를 정의하여 어떤 객체의 상태가 변할 때, 의존 관계에 있는 모든 객체들이 통지받고 자동으로 갱신될 수 있게 만드는 패턴이다.

[Design Pattern](https://coding-factory.tistory.com/708)



# Agile

- 빠르게 취하고 낭비없게 만든는 다양한 방법론을 말한다.
- 앞을 예측하지 않고 일정한 주기를 가지고 계속 검토해 나가며 필요할 때마다 요구사항을 더하고 수정하는 방식을 한다.
- 경험 기반 프로세스이며 적시(just-in-time)설계
- 코드강조
- 팀워크 중시
- 장점
  - 프로젝트 계획에 걸리는 시간 최소화
  - 버그를 쉽고 빠르게 발견 가능
  - 수정과 변경에 유연
  - 즉각적인 피드백으로 프로토타입 모델 빠른 출시
- 단점
  - 확정되지 않은 계획 및 요구사항으로 인한 반복적인 유지보수 작업이 많다.
  - 개인이 아닌 팀이 중심이어서 공통으로 해야할 작업이 많다(회의).

## Scrum

- 스프린트 - 크지 않은 태스크를 적당한 기간동안 집중해서 전력질주하듯 업무를 수행하는 것이다. 스크럼 내부에 있으며 계획 회의 부터 제품 리뷰까지 기간이 1스프린트이다.
- 스프린트 백로그 - 스프린트 목표에 도달하기 위해 필요한 작업 목록
- 스크럼 회의 - 날마다 진행되는 미팅(어제한일, 오늘할일, 장애현상)
- 제품 책임자(product owner) - 제품 백 로그를 정의하여 우선순위를 정해 준다.
- 스크럼 마스터(Scrum Master) - 일반적인 관리를 수행하는 프로젝트 관리자들과는 달리 팀원을 코칭하고 프로젝트의 문제 상황을 해결하는 역할을 하며, 제품 책임자는 스프린트 목표와 백로그 등의 결정에 있어 중심이 되는 상위 관리자이다.



# Thread Safe

Multi Thread 프로그래밍에서 여러 Thread로부터 어떤 method나, variable, object에 동시에 접근이 이루어져도 프로그램의 실행에 문제가 없는 것을 말한다.

- HashMap 대신 ConcurrentHashMap 사용
- Long 대신 AtomicLong 사용
- StringBuilder 보다 StringBuffer이 Thread Safe 하다.
- 빈에 변할 수 있는 변수가 있다면 Thread Safe하지 않다. 이때 지역변수로 사용하거나 scope을 prototype으로 하여 singleton이 아닌 새로운 객체 생성되게 한다. 아니면 읽기 전용으로 만들어서 setter을 삭제해야 한다.

[Thread Safe](https://velog.io/@cateto/Java-Thread-Safe%EB%9E%80)



# AOP & Filter & Interceptor



## AOP

AOP는 관점 지향 프로그래밍으로 객체를 추상화하여 모듈화 하는 것이다.

- 주소가 아닌 파라미터, 어노테이션 등으로 대상 설정이 가능하다.
- 공통처리에 사용되며 로깅이나 실행시간 체크 시 이용한다.



## Filter

자바 표준을 활용하며 웹 컨테이너가 관리한다.

- Dispatcher Servlet 전에 호출된다.
- 보안, 인증, 인가, 압축, 인코딩 시 사용된다.



## Interceptor

스프링이 제공하는 기술이며 스프링 컨테이너가 관리한다.

- Dispatcher Servlet 이후에 호출된다.
- 클라이언트의 요청과 관련되어 전역적으로 처리해야 하는 작업들을 처리해야 한다.
- 컨트롤러로 넘겨주기 위한 정보를 가공한다.

[AOP & Filter & Interceptor](https://www.saichoiblog.com/springboot-filterling/)





# MSA

단일 프로그램을 각 컴포넌드 별로 나누어 작은 서비스의 조합으로 구축하는 방법이다. 서비스를 모듈화 한다고 생각하면 된다.



## Monolithic

전체 어플리케이션이 하나로 되어있는 구조이다.

![leh_3](http://clipsoft.co.kr/wp/wp-content/uploads/2020/06/leh_3.png)

- 하나의 덩어리로 된 구조이다.
- 각 컴포넌트들이 함수로 호출되기 때문에 성능에 제약이 덜하고 운영 관리가 용이하다.
- 작은 볼륨의 시스템을 개발할 때는 유용하지만 시스템이 커지기 시작하고 여러 컴포넌트들이 더해지면 문제가 발생한다.
- 단점
  - 빌드 / 테스트 시간이 길어진다.
    - 작은 수정에도 시스템 전체를 빌드해야 하며 테스트 시간도 길어진다.
    - CI / CD 시 오래 걸린다.
  - 선택적 확장이 불가능하다.
    - 이벤트로 인해 서비스 접속량이 폭증할 경우 프로젝트 전체를 확장해야 한다.
  - 하나의 서비스가 모든 서비스에 영향을 준다.
    - 이벤트 서비스에 트래픽이 몰려 해당 서버가 죽게 된다면 다른 모든 서비스 역시 마비된다.



## MSA

작은 서비스를 기준으로 구성되는 구조이다. 서비스 지향적 아키텍쳐 스타일이다.

![leh_4](http://clipsoft.co.kr/wp/wp-content/uploads/2020/06/leh_4.png)

- 장점

  - 각 컴포넌트는 서비스 형태로 구현되고 API를 이용하여 타 서비스와 통신한다.
  - 각 서비스는 독립된 서버이므로 독립된 배포를 한다.
  - 각 컴포넌트가 독립된 서비스로 개발되어 있기 때문에 부분적인 확장이 가능하다(이벤트 서버만 스케일링).

- 단점

  - 모놀리틱 아키텍처는 서비스간 호출이 하나의 프로세스 내에서 이루어지기 때문에 속도가 빠르지만 MSA 경우 서비스간 호출을 API 통신을 이용하기 때문에 속도가 느리며 통신에 사용하기 위해 값을 데이터 모델로 변환시켜주는 오버헫가 발생하기도 한다.

- 특징

  - 데이터분리

    - 데이터 저장 시 하나의 DB에 중앙 집중화를 하지 않고 서비스 별 별도의 데이터 베이스를 사용한다.
    - 같은 DB를 사용하더라도 나누어서 사용하게 된다.
    - 장점
      - 데이터가 분산되어있기 때문에 다른 서비스 컴포넌트에 대한 의존성이 없이 서비스를 독립적으로 개발 및 배포 / 운영 할 수 있다.
    - 단점
      - 다른 컴포넌트의 데이터를 API통신을 통해 가져와야 하기 때문에 성능상 문제가 발생할 수 있다.
      - 트랜잭션으로 쿼리를 묶을 수 없는 문제가 발생한다.

  - API Gateway

    - MSA의 문제점 중 하나는 각 서비스가 다른 서버에 분리 배포되어있기 때문에 서버 URL이 각기 다를 수 밖에 없다.
    - 이때 API Gateway는 API 서버 앞 단에서 모든 API 서버들의 End-Point를 단일화하여 묶어주는 역할을 한다.
    - 거미줄처럼 복잡한 서비스간의 API호출 구조도 단순화 시킨다.
    - 라우팅, 로드밸런싱, 인증 역할도 수행한다.

  - 팀의 변화

    - 기존 모놀리틱의 팀 모델은 역할 별로 나누어진 모델로 팀을 구분했다.
    - 이러한 팀 모델은 인력 관리와 운영에 유연성을 부여하지만 팀 간의 커뮤니케이션이 원활하지 않고 협업에 걸리는 시간이 지연되는 경우가 많다.
    - 기획, UX, 개발, 인프라 운영 팀이 존재하며 각각 독립적이다.

    ![leh_5](http://clipsoft.co.kr/wp/wp-content/uploads/2020/06/leh_5.png)

    - MSA에서는 서비스 별로 팀을 나누고 서비스 기획에서부터 설계 개발 운영이 팀 내에서 이루어지기 때문에 다른 팀에 대한 의존성이 사라진다.
    - 역할별 요청과 피드백이 빨라지고 유연하고 지속적인 운영과 개발이 함께된다.
    - 하지만 각 팀의 역할 담당자는 기본적인 업무 성숙도를 가지고 있어야 하며 개발팀은 운영팀의 인프라 핸들링까지 해야한다(AWS같은 클라우드 발달로 가능해졌다).

    ![leh_6](http://clipsoft.co.kr/wp/wp-content/uploads/2020/06/leh_6.png)



## Spring Cloud Eureka

Spring Cloud는 마이크로서비스 아키텍처를 지원하는 스프링부트를 기반으로 하는 프레임워크이다.

- Spring Cloud Config Server라는 외부 저장소에 환경설정을 설정한다. 이때 외부 저장소는 Git이 된다.
  - 이를 사용하면 각각의 마이크로서비스의 내용이 변경된다고 해도 다시 빌드하지 않아도 되고 외부저장소에 있는 환경설정만 바꿔준다면 연결되어 있는 마이크로 서비스들의 환결설정이 자동으로 변경되어 유지보수에 좋아진다.
  - 사용 이유
    - 첫째, 마이크로서비스의 어떠한 설정(환경변수값, Spring cloud 설정 등)이 변경되었을때 서버 재시작 없이 동적으로 적용하기 위해서이다.
    - 둘째, 마이크로서비스가 배포될때 제반 설정값들을 배포 대상 환경(개발계, 검증계, 운영계 등)에 맞게 적용하기 위함이다.
    - 셋째, 마이크로서비스를 Stateless하게 개발하기 위해서입니다. Stateless하게 만들어야 스케일링(마이크로서비스 인스턴스 서버 - 즉, 컨테이너의 증감)과 부담없는 재시작이 가능하기 때문이다.

![img](https://blog.kakaocdn.net/dn/tsc82/btq7ixD4f5U/x6JKAVXUWBxdYiw41Yrh30/img.png)

- Spring Cloud Gateway를 통해서 외부 또는 내부의 서비스에서 오는 요청이 원하는 서비스를 찾아갈 수 있다. Naming Server는 찾고자 하는 서비스의 위치를 저장한다.
  - Tomcat이 아닌 Netty를 사용하여 비동기 WAS이고 1Thread / Many Request 방식으로 기존 방식보다 더 많은 요청을 처리한다.
  - API Gateway는 클라이언트와 백엔드 서비스 사이에 위치하는 리버스 프록시 역할을 한다.
  - API Gateway는 서버 최앞단에 위치하여 모든 API 호출을 받고 인증 후 적절한 서비스들에 메시지를 전달한다.
  - 인증 및 권한, 모니터링, 로깅 등 기능도 한다.
- Spring Cloud Eureka(Netflix OSS)는 Naming Server로 단위 서비스들에 대해 동적으로 서비스 등록(Service Registry) 및 서비스 디스커버리(Service Discovery)를 수행하고 로드밸런싱을 통해 서비스간 통신의 부하 분산 기능을 한다.
  - Eureka는 각 서비스에서 보내는 하트비트(HeartBeat) 방식으로 상태 정보를 받아들이고 상태 점검(Health Check)를 한다.
  - 만약 하트비트가 수신되지 않은 경우 레지스트리에서 해당 서비스 정보가 제거된다.
  - Eureka의 부하 분산은 클라이언트-사이드 방식의 리본을 사용한다.



[MSA1](http://clipsoft.co.kr/wp/blog/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98msa-%EA%B0%9C%EB%85%90/)

[MSA2](https://www.samsungsds.com/kr/insights/1239180_4627.html)

[Spring Cloud Config Server](https://happycloud-lee.tistory.com/209)

[API Gateway](https://m.blog.naver.com/dktmrorl/222129517689)

[Spring Cloud Gateway](https://saramin.github.io/2022-01-20-spring-cloud-gateway-api-gateway/)



# Message Queue

메시지들을 큐라는 자료구조에 담아서 관리한다는 의미이다.



## MOM

"메시지 지향 미들웨어" 라고 부른다.

응용 소프트웨어 간의 데이터(비동기 메시지) 통신을 위한 소프트웨어이다.

![img](https://blog.kakaocdn.net/dn/bzojLH/btrcFV6Bj5V/cgVBm4FFu840FgA9b0Cd9k/img.png)

- 메시지 지향 미들웨어는 메시지를 전달하는 과정에서 보관하거나 라우팅 및 변환할 수 있다는 장점이 있다.
  - 보관 : 메시지의 백업을 유지함으로써 지속성을 제공, 덕분에 송수신 측은 동시에 네트워크 연결을 유지할 필요가 없다.
  - 라우팅 : 미들웨어 계층 자신이 직접 메시지 라우팅이 가능하기 때문에 하나의 메시지를 여러 수신자에게 배포가 가능해진다(멀티캐스트).
  - 변환 : 송수신 측의 요구에 따라 메시지를 변환할 수 있다.
- 단점
  - 아케텍처에 외부 구성 요소인 메시지 전송 에이전트가 필요, 일반적으로 새로운 요소를 추가할 경우 시스템 성능이 저하되고 신뢰성이 떨어진다.
  - 시스템이 복잡해지기 때문에 관리가 어렵고 비용이 발생한다.
  - 어플리케이션 간의 통신은 본질적으로 동기지만 메시지 기반 통신은 본질적으로 비동기이기 때문에 메커니즘 불일치가 발생한다.



## Message Queue

메시지 큐는 메시지 지향 미들웨어(MOM)를 구현한 시스템으로 프로그램(프로세스) 간의 데이터를 교환할 때 사용하는 기술이다.

![img](https://blog.kakaocdn.net/dn/Ngglq/btrcBzwwxTZ/q8QoaXArd36vlklhu85KT0/img.png)

- 장점
  - **비동기(Asynchronous)** : 데이터를 수신자에게 바로 보내지 않고 큐에 넣고 관리하기 때문에 나중에 처리 가능
  - **비동조(Decoupling)** : 애플리케이션과 분리할 수 있기 때문에 확장이 용이해짐
  - **탄력성(Resilience)** : 일부가 실패하더라도 전체에 영향을 주지 않음
  - **과잉(Redundancy)** : 실패할 경우 재실행 가능
  - **보증(Guarantees)** : 작업이 처리된 걸 확인할 수 있음
  - **확장성(Scalable)** : N:1:M 구조로 다수의 프로세스들이 큐에 메시지를 보낼 수 있음
- 메시지 큐는 대용량 데이터를 처리하기 위한 배치 작업, 채팅 서비스, 비동기 데이터 처리 시 사용한다.
- 다량의 요청을 바로 서버로 보내지 않고 메시지 큐에 보관하고 서버 측에서는 처리하는데 이상 없을 정도의 요청들만 메시지 큐에서 가져와서 처리하여 서버 부담을 줄인다.
- RabbitMQ, ActiveMQ는 신뢰성 있는 메시지 브로커가 필요한 경우 사용하며 Kafka는 처리량이 많은 분산 메시징 시스템에서 사용된다.

[Message Queue](https://sorjfkrh5078.tistory.com/291)



# Cloud



## Public Cloud

퍼블릭 클라우드는 리소스를 클라우드 서비스 공급자가 소유하고 인터넷을 통해 제공하는 클라우드이다.

- 하드웨어, 소프트웨어 지원 인프라를 공급자가 소유하고 관리한다.
- 여기서 공급자는 외부 기업 및 데이터 센터이다.
- Pay as you go 정책을 따른다.
- Ex) AWS, Azure, GCP
- 장점
  - 비용절감
    - 하드웨어 또는 소프트웨어를 구매할 필요가 없으며, 사용한 서비스의 요금만 지불하면 된다.
  - 유지관리 불필요
    - 서비스 공급자가 유지 관리를 제공한다.
  - 무제한에 가까운 스케일링 기능
    - 주문형 리소스를 사용하여 비즈니스 요구 사항을 충족할 수 있다.
- 단점
  - 업체 종속
    - 클라우드 업체가 제공하는 가상 머신, 스토리지, 애플리케이션, 기술 등의 서비스에 종속될 수 있다.



## Private Cloud

프라이빗 클라우드는 하나의 조직에 전용 클라우드 환경을 제공하는 모델이다.

- 프라이빗 클라우드에서는 서비스와 인프라가 항상 프라이빗 네트워크에서 유지 관리되며 하드웨어와 소프트웨어는 조직에서만 전용으로 사용된다.
- 인트라넷 클라우드라고도 불린다.

- Ex) VMware, Openstack
- 장점
  - 유연성 향상
    - 조직에서 특정 비즈니스 요구 사항을 충족하기 위해 클라우드 환경을 사용자 지정할 수 있다.
  - 제어 향상
    - 리소스가 다른 사용자와 공유되지 않으므로 더 높은 수준의 제어 및 개인 정보 보호가 가능하다(보안 우수).
  - 스케일링 성능 향상
    - 온프레미스보다 큰 스케일링 성능을 제공한다.
- 단점
  - 관리비용 및 책임
    - 조직이 관리 비용과 책임을 맡아야하며 인력, 관리, 유지비용이 증가한다.



## Hybrid Cloud

하이브리드 클라우드는 VPN 등의 보안 연결을 통해서 하나 이상의 퍼블릭 클라우드 + 프라이빗 클라우드 환경을 결합하는 방식이다.

- 활용 예
  - 이메일같은 자사의 독자성이 필요없는 서비스는 퍼블릭 클라우드를 이용하고 인사정보나 개인 인증 정보같은 보안성이 필요한 정보는 프라이빗 클라우드에 저장한다.
  - 외부 개발자와 함께 개발할 때는 퍼블릭 클라우드에서 작업하고 개발 결과물은 프라이빗 클라우드로 옮겨서 자사 전용으로 서비스한다.
- 장점
  - 제어
    - 조직이 짧은 대기 시간이 필요한 중요한 자산이나 워크로드를 위한 프라이빗 인프라를 유지 관리할 수 있다.
  - 유연성
    - 필요할 때 퍼블릭 클라우드에서 추가 리소스를 사용할 수 있다.
  - 비용 효율성
    - 퍼블릭 클라우드로 스케일링하는 기능을 통해 필요할 때만 추가 컴퓨팅 성능의 비용을 지불하면 된다.



[Public, Private, Hybrid Cloud1](https://azure.microsoft.com/ko-kr/resources/cloud-computing-dictionary/what-are-private-public-hybrid-clouds/#benefits)

[Public, Private, Hybrid Cloud2](https://owin2828.github.io/devlog/2020/01/10/aws-1.html)

[Public, Private, Hybrid Cloud3](https://ttend.tistory.com/691)



## As a Service

"서비스형(as-a-Service)"는 제 3사에서 클라우드 컴퓨팅 서비스를 제공한다는 의미이다.

- 사용자는 코드, 고객 관계 관리와 같은 더 중요한 업무에 집중할 수 있다.
- 비용이 절감된다.
- 관리가 쉬워진다.
- 스케일링이 가능하다.

![img](https://www.redhat.com/cms/managed-files/iaas-paas-saas-diagram5.1-1638x1046.png)



### IaaS

제 3사가 스토리지와 가상화와 같은 인프라 서비스를 인터넷을 통해 클라우드로 제공하는 것이다.

- 일반적으로 사용하는 클라우드이다.
- 사용자는 운영 체제 및 데이터, 애플리케이션, 미들웨어 및 런타임을 담당하고 제공업체는 사용자가 필요로 하는 네트워크, 서버, 가상화 및 스토리지의 관리와 액세스를 담당한다.
- 장점
  - 필요한 구성 요소만 구매하고 필요에 따라 확장 또는 축소할 수 있는 유연성을 제공한다. 사용자의 재량에 따라 과금되는 경제적인 옵션이다.
  - 개발 및 테스트 환경의 구축 및 제거가 빠르고 유연하다는 장점이 있다. 언제나 스케일링 및 중단 가능하다.
- 단점
  - 제공 업체의 보안 문제 가능성이 있다.
- Ex) AWS, Azure, GCP



### PaaS

제공 업체가 자체 인프라에서 하드웨어와 소프트웨어를 호스팅하고 이러한 플랫폼을 사용자에게 통합 솔루션, 솔루션 스택 또는 인터넷을 통한 서비스로 제공한다.

- 해당 프로세스와 관련된 인프라 또는 플랫폼을 구축하고 유지관리할 필요 없이 사용자가 자체 애플리케이션을 개발, 실행 및 관리할 수 있도록 한다.
- 사용자는 애플리케이션 코드를 작성, 빌드, 관리하지만 소프트웨어 업데이트 또는 하드웨어 유지관리와 같은 번거로움이 사라진다. 빌드 및 배포를 위한 환경이 사용자에게 제공된다.
- 개발자가 프레임워크를 개발하여 지속적으로 웹 기반 애플리케이션을 빌드 및 커스터마이징할 수 있는 방법이다. 개발자는 기본 소프트웨어 구성 요소를 활용하여 자체 애플리케이션을 개발할 수 있으므로 자체적으로 작성해야 하는 코드의 양을 줄일 수 있다.
- Ex) AWS Elastic Beanstalk, Heroku, Red Hat OpenShift



### SaaS

가장 포괄적인 형식의 클라우드 컴퓨팅 서비스로 모든 애플리케이션은 제공업체가 관리하며 웹 브라우저를 통해 제공된다.

- 제공업체가 소프트웨어 업데이트, 버그 수정 및 기타 일반 소프트웨어 유지관리 작업을 처리하며 사용자는 대시보드 또는 API를 통해 애플리케이션을 연결한다.

- 클라우드로 만든 서비스 자체를 제공하는 것으로 google 계정이 지원하는 서비스들을 말한다.
- 현재 개발중인 Fillkie도 SaaS다.
- Ex) Dropbox, Salesforce, Google Apps







[as-a-Service](https://www.redhat.com/ko/topics/cloud-computing/iaas-vs-paas-vs-saas)