# Database



## 설계



### 개념적 설계

- 현실 세계에 대한 인식을 추상적 개념으로 표현한 것이다.
- 스키마 모델링과 트랜잭션 모델링을 병행한다.
- 요구 분석 단계에서 나온 결과를 DBMS에 독립적 ERD로 작성한다.



### 논리적 설계

- 현실 세계 자료를 컴퓨터 처리할 수 있는 물리적 저장 장치에 저장할 수 있도록 변환하기 위해 특정 DBMS가 지원하는 논리적 자료 구조로 변환한다.
- 개념적 설계는 개념 스키마를 설계하는 것이지만 논리적 설계는 개념 스키마 평가, 정제 그리고 특정 DBMS에 종속적인 논리적 스키마를 설계하는 것이다.
- 트랜잭션의 인터페이스를 설계한다.
- 즉, DBMS의 관점에서 개념적 스키마를 변환하는 것이다.
- RDB라면 테이블을 설계하고 정규화 과정을 하는 단계이다.



### 물리적 설계

- 논리적으로 설계된 스키마를 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터베이스로 변환하는 것이다.
- 파일의 저장 구조 및 엑세스 경로, 인덱스의 구조와 저장 레코드의 크기, 순서, 접근 경로를 결정하며 반응시간, 공간활용도, 트랜잭션 처리량을 고려하여 설계를 해야 한다.



## 키

데이터베이스에서 조건을 만족하는 튜플을 찾을 때 다른 튜플들과 구별할 수 있는 유일한 기준이 되는 애트리뷰트이다.



### 후보키

- 릴레이션을 구성하는 속성들 중에서 튤플을 유일하게 식별하기 위해 사용하는 속성들의 부분집합이다.
- 유일성과 최소성을 만족해야한다.
- 모든 릴레이션은 반드시 하나 이상의 후보키를 가져야한다.



### 기본키

- 후보키 중에서 선택한 주키이다.
- 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성이다.
- NULL 값을 가질 수 없다. (개체 무결성)
- 동일한 값이 중복되어 저장될수 없다. (개체 무결성)



### 대체키

- 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키이다.
- 보조키라고도 불린다.



### 슈퍼키

- 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키이다.
- 유일성의 특셩을 만족하는 속성 또는 속성들의 집합이다.
- 릴레이션을 구성하는 모든 튜플 중 슈퍼키로 구성된 속성의 집합과 동일한 값은 나타내지 않는다.
- 릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족하지만 최소성을 만족하지 않는다.



### 외래키

- 관계를 맺고 있는 릴레이션들이 서로의 값을 참조하기 위해 상대 테이블의 기본키를 자신의 속성으로 갖는 것이다.
- 참조되는 릴레이션의 기본키와 대응되어 릴레이션 간에 참조 관계를 표현하는데 중요한 도구가 된다.
- 외래키로 지정되면 참조 테이블의 기본키에 없는 값은 입력할 수 없다. (참조 무결성)



### 복합키

- 기본키가 2개 이상으로 구성된 것이다.

[설계 & 키](https://velog.io/@inyong_pang/Database-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%84%A4%EA%B3%84-%EB%B0%8F-%EA%B5%AC%EC%A1%B0)

[키](https://limkydev.tistory.com/108)



## 데이터 무결성

데이터의 정확성, 일관성, 유효성이 유지되는 것을 말한다.

개참도널고키

- 정확성 : 중복이나 누락이 없는 상태를 뜻한다.
- 일관성 : 원인과 결과의 의미가 연속적으로 보장되어 변하지 않는 상태를 뜻한다.
- 무결성이 없다면 : 중복된 데이터 존재, 부모와 자식 데이터 간의 논리적 관계 깨짐, 잦은 에러와 재개발 비용 발생 문제가 발생한다.



### 개체 무결성

- 기본키 제약이며 테이블은 기본키를 지정하고 그에 따른 무결성 원칙을 지켜야하는 조건이다.
- 기본키에는 NULL이 들어갈 수 없다.
- 기본키는 테이블 내에 오직 하나의 값만 존재해야 한다. 즉, 유일성이 보장 되어야하며 중복을 허용하지 않는다.



### 참조 무결성

- 외래키 제약이며 테이블 간의 참조 관계를 선언하는 제약조건이다.
- 외래키의 값은 NULL이거나 참조 릴레이션의 기본키 값과 동일해야 한다.
- 외래키 속성은 참조할 수 없는 값을 지닐 수 없다. 즉, 외래키 속성 값이 상위 테이블의 인스턴스에 반드시 존재하거나 NULL이어야 한다.



### 도메인 무결성

- 테이블에 존재하는 필드의 무결성을 보장하기 위한 것으로 필드의 타입, NULL 값 허용 등에 대한 사항을 정의하고 올바른 데이터가 입력되었는지 확인하는 조건이다.
- 즉, 속성에 알맞은 값이 들어갔는지 확인하는 것이다.
- 예) `성별 : 남자 (O), 성별 : 강민우 (X)`



### NULL 무결성

- 테이블의 특정 속성 값이 NULL이 될수 없게 하는 조건이다.



### 고유 무결성

- 테이블의 특정 속성에 대해 각 레코드들이 갖는 값들이 서로 달라야하는 조건이다.



### 키 무결성

- 하나의 테이블에는 적어도 하나의 키가 존재해야 한다.



### 관계 무결성

- 테이블의 어느 한 레코드의 삽입 가능 여부 또는 한 테이블과 다른 테이블의 레코드들 사이의 관계에 대한 적절성 여부를 지정한 조건이다.

[데이터 무결성](https://cocoon1787.tistory.com/778)



## 트랜잭션

여러 개의 작업을 하나로 묶은 실행 유닛을 뜻한다.

데이터베이스의 상태를 변환시키는  기능을 수행하기 위한 하나 이상의 쿼리를 모아 놓은 하나의 작업 단위를 말한다.

- 모든 묶은 작업이 완료되어야 정상적으로 종료하며 하나라도 실패하면 모든 작업 실패로 판단한다.

ACID

- 데이터베이스 내에서 일어나는 하나의 트랜잭션의 안전성을 보장하기 위해 필요한 성질이다.



### Atomicity

- 트랜잭션이 안전성 보장을 위해 가져야 할 성질이다.

- 한 트랜잭션의 연산들이 모두 성공하거나 반대로 전부 실패하는 성질이다.
- 하나의 작업이라도 실패하면 실패이다.
- 원자성은 작업이 모두 반영되거나 모두 반영되지 않음으로서 결과를 예측할 수 있어야 한다.
- 예 ) A는 출금하여 B계좌에 입금할 때 B가 문제가 발생하면 문제 파악이 불가능해지며 A가 출금한 돈은 사라진 돈이 된다. 이때 원자성이 필요하다. 즉, 롤백해야 한다.



### Consistency

- 하나의 트랜잭션 이전과 이후, 데이터베이스의 상태는 이전과 같이 유효해야 한다.
- 트랜잭션이 일어난 이후의 데이터베이스는 데이터베이스의 제약이나 규칙을 만족해야 한다.
- 예 ) '모든 고객은 반드시 이름을 가지고 있어야 한다'는 제약이 있을 때 1. 이름이 없는 새로운 고객을 추가하는 쿼리 2. 기존 고객의 이름을 삭제하는 쿼리는 일관성을 위반한다.



### Isolation

- 모든 트랜잭션은 다른 트랜잭션으로부터 독립되어야 한다.
- 실제로 동시에 여러 개의 트랜잭션들이 수행될 때, 각 트랜젝션은 고립되어 있어 연속으로 실행된 것과 동일한 결과를 나타낸다.
- 트랜잭션이 동시에 실행될 때와 연속으로 실행될 때의 데이터베이스 상태가 동일해야 한다.
- 예 ) 만원이 들어있는 계좌에서 동시에 B, C 계좌에 각각 6천원씩 보낼때 마이너스 통장이 발생하면 안되며 송금 작업을 연속으로 실행하는 것과 동시에 실행하는 결과는 동일한 결과가 나타나야 한다.



### Durability

- 하나의 트랜잭션이 성공적으로 수행되었다면 해당 트랜잭션에 대한 로그가 남아야하는 성질을 말한다.
- 만약 런타임 오류나 시스템 오류가 발생하더라도 해당 기록은 영구적이어야 한다.
- 예 ) 은행 데이터베이스가 오류로 종료되어도 계좌이체 내역은 기록으로 남아 있어야 한다. 만약 계좌 이체를 로그로 기록하기 전에 오류로 데이터베이스가 종료되면 해당 이체 내역은 실패로 돌아가고 각 계좌들은 계좌 이체 이전 상태로 롤백된다.

[트랜잭션](https://hanamon.kr/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%98-acid-%EC%84%B1%EC%A7%88/)



## 데이터베이스 관계

3가지 유형



### 1:1

- 하나의 레코드가 다른 테이블의 레코드 한 개와 연결된 경우이다.
- 어느 엔티티 쪽에서 상대 엔티티와 반드시 단 하나의 관계를 가지는 것이다.



### 1:N

- 하나의 레코드가 서로 다른 여러 개의 레코드와 연결된 경우이다.
- 한 쪽 엔티티가 관걔를 맺은 엔티티 쪽의 여러 객체를 가질 수 있는 것을 의미한다.



### N:M

- 여러 개의 레코드가 다른 테이블의 여러 개의 레코드와 관계가 있는 경우이다.
- 스키마를 디자인한다면 join 테이블을 만들어야 한다. 1:N N:1로 풀어서 릴레이션을 구성하는 것이 좋다.
- 양쪽 엔티티 모두에서 1:N 관계를 가지는 것으로 보면 되며 서로가 서로를 1:N 관계로 보는 것이다.

[데이터베이스 관계](https://hanamon.kr/%EA%B4%80%EA%B3%84%ED%98%95-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%84%A4%EA%B3%84-%EA%B4%80%EA%B3%84-%EC%A2%85%EB%A5%98/)



## DBMS SQL

데이터베이스에서 모든 작업은 SQL로 이루어지며 종류는 DDL, DML, DCL이 있다.

DDL : 데이터베이스와 테이블을 생성 및 변경, 제거 한다.

DML : 생성된 테이블 내에 있는 데이터들을 입력, 변경, 수정, 조회 한다.

DCL : 데이터베이스의 접속 권한 등을 수정한다.



### DDL

- 데이터 정의어 이다.

- 데이터베이스를 정의하는 언어를 말하며 데이터를 생성하거나 수정, 삭제 등 데이터의 전체 골격을 결정하는 역할을 하는 언어이다.
- 데이터 구조를 정의하는데 사용되는 언어이다.
- CREATE : 데이터베이스, 테이블 등을 생성하는 역할을 한다.
- ALTER : 테이블을 수정하는 역할을 한다.
- DROP : 데이터베이스, 테이블을 삭제하는 역할을 한다.
- TRUNCATE : 테이블을 초기화 시키는 역할을 한다.



### DML

- 데이터 조작어 이다.
- 정의된 데이터베이스에 입력된 레코드를 조회하거나 수정하거나 삭제하느 등의 역할을 하는 언어이다.
- 테이블에 있는 행과 열을 조작하는 언어이다.
- SELECT : 데이터를 조회하는 역할을 한다.
- INSERT : 데이터를 삽입하는 역할을 한다.
- UPDATE : 데이터를 수정하는 역할을 한다.
- DELETE : 데이터를 삭제하는 역할을 한다.



### DCL

- 데이터 제어어 이다.
- 데이터베이스에 접근하거나 객체에 권한을 주는 등 역할을 하는 언어이다.
- 데이터의 보안, 무결성, 회복 등을 정의하는데 사용한다.
- GRANT : 특정 데이터베이스 사용자에게 특정 작업에 대한 수행권한 부여를 한다.
- REVOKE : 특정 데이터베이스 사용자에게 특정 작업에 대한 권한을 박탈, 회수한다.
- COMMIT : 트랜잭션의 작업이 정상적으로 완료되었음을 관리자에게 알려준다.
- ROLLBACK : 트랜잭션의 작업이 비정상적으로 종료 되었을 때 원래의 상태로 복구한다.

[DBMS SQL](https://cbw1030.tistory.com/71)



## 이상

릴레이션에서 일부 속성들의 종속이나 데이터의 중복으로 인해 데이터 조작시 불일치가 발생하는 것이다.



### 삽입 이상

- 자료를 삽입할 때 의도하지 않은 자료까지 삽입해야만 자료를 테이블에 추가가 가능한 이상이다.
- 예 ) 강의를 아직 수강하지 않은 새로운 학생을 삽입할 경우 강의코드 속성에는 null 값이 들어가야 한다.



### 갱신 이상

- 중복된 데이터 중 일부만 수정되어 데이터 모순이 일어나는 이상이다.



### 삭제 이상

- 어떤 정보를 삭제하면 유용한 다른 정보까지 삭제되어버리는 이상이다.

[이상](https://kosaf04pyh.tistory.com/294)



## 정규화

테이블 간 중복된 데이터를 허용하지 않게 만드는 것이다.

중복된 데이터를 허용하지 않음으로써 무결성을 유지할 수 있으며 DB의 저장 용량을 줄일 수 있다.

즉, 이상을 제거하는 과정이다.



### 제 1 정규화

- 테이블의 컬럼이 원자값(하나의 값)을 갖도록 테이블을 분해하는 것이다.
- 즉, 각 테이블은 2개 이상의 값을 가지면 안되며 2개 이상일 때에는 레코드를 2개 이상으로 나눠주어야 한다.



### 제 2 정규화

- 제 1 정규화를 진행한 테이블에 대해 완전 함수 종속을 만족하도록 테이블을 분해하는 것이다.
- 완전 함수 종속이란 기본키의 부분집합이 결정자가 되어선 안된다는 것이다.
- 즉, 부분 함수 종속을 없애는 것이다.
- 기본키가 복합키일 때 부분키가 결정자가 되는 상황을 2개의 테이블로 나눈뒤 외래키로 참조하는 것이다.



### 제 3 정규화

- 제 2 정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블을 분해하는 것이다.
- 이행적 종속은 A -> B, B -> C, A -> C 가 성립하는 것을 말한다. 즉, A는 B를 결정하고 있고 B는 C를 결정하고 있는 것이다. 이것을 A,B 테이블, B,C 테이블로 분해해야 한다. 그리고 외래키로 참조해야 한다.

[정규화](https://mangkyu.tistory.com/110)



## 뷰

사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된 이름을 가지는 가상 테이블이다.

- 뷰는 저장장치 내에 물리적으로 존재하지 않지만 사용자에게 있는 것처럼 간주된다. 뷰는 데이터 딕셔너리 테이블에 뷰에 대한 정의만 저장되지 디스크 공간에 할당되지 않는다.
- 뷰는 데이터 보정작업, 처리과정 시험 등 임시적인 작업을 위한 용도로 활용된다.
- 뷰는 조인문의 사용 최소화로 사용상의 편의성을 최대화 한다.
- 기본 테이블의 기본키를 포함한 속성 집합으로 뷰를 구성해야하지만 삽입, 삭제, 갱신, 연산이 가능하다.
- 뷰나 기본 테이블이 삭제되면 그 뷰나 테이블을 기초로 정의된 다른 뷰도 자동으로 삭제된다.
- 뷰는 ALTER문 사용이 불가능하다. 그래서 필요할 경우 삭제한 후 재생성한다.
- RESTRICT : 뷰를 다른 곳에서 참조하고 있으면 삭제가 취소된다.
- CASCADE : 뷰를 참조하는 다른 뷰나 제약 조건까지 모두 삭제된다. 참조 무결성을 위해 존재한다. 즉, PK, FK 간의 관계가 항상 유효하도록 관리하는 것으로 PK를 참조하는 FK가 있다면 해당 PK는 수정과 삭제가 불가능하다.
- 장점
  - 논리적 데이터 독립성을 제공한다.
  - 동일 데이터에 대해 동시 여러 사용자의 요구를 들어서 지원할 수 있다.
  - 접근 제어를 통한 자동 보안이 제공된다.
- 단점
  - 독립적인 인덱스를 가질 수 없다.
  - ALTER 사용 불가능하다.
  - 뷰로 구성된 내용에 대한 삽입, 삭제, 갱신, 연산에 제약이 따른다.

[뷰](https://coding-factory.tistory.com/224)



ERD

Index

Index hunting

Checkpoint

Trigger

저장 프로시저

교착상태

NoSQL RDBMS

NoSQL 쓰는 이유

Delete Drop Truncate 차이